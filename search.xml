<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序算法</title>
    <url>/2020/09/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hexo博客中添加tags和categories页</title>
    <url>/2019/12/05/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0tags%E5%92%8Ccategories%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="1-新建一个页面，命名为tags。命令如下："><a href="#1-新建一个页面，命名为tags。命令如下：" class="headerlink" title="1. 新建一个页面，命名为tags。命令如下："></a>1. 新建一个页面，命名为tags。命令如下：</h2><p><code>hexo new page &quot;tags&quot;</code></p>
<blockquote>
<p>  在myBlog/source下会新生成一个新的文件夹tags<br>，在该文件夹下会有一个index.md文件 </p>
</blockquote>
<h2 id="2-编辑tags文件夹下的index-md"><a href="#2-编辑tags文件夹下的index-md" class="headerlink" title="2. 编辑tags文件夹下的index.md"></a>2. <strong>编辑tags文件夹下的index.md</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2017-07-10 16:36:26</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="3-在菜单中添加链接。编辑主题的-themes-next-config-yml-，添加tags到menu中，如下"><a href="#3-在菜单中添加链接。编辑主题的-themes-next-config-yml-，添加tags到menu中，如下" class="headerlink" title="3. 在菜单中添加链接。编辑主题的 themes/next/_config.yml ，添加tags到menu中，如下:"></a>3. <strong>在菜单中添加链接。编辑主题的 <code>themes/next/_config.yml</code> ，添加tags到menu中，如下:</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;|| home</span><br><span class="line">  about: &#x2F;about&#x2F;|| user</span><br><span class="line">  tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">  categories: &#x2F;categories&#x2F;|| th</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>在上述过程中，一定不要在“/”后面加空格，不然就会报错，显示网页404</strong></p>
</blockquote>
<p>之后的categories方式同上。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript基础学习</title>
    <url>/2020/07/19/Javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Javascript基础学习"><a href="#Javascript基础学习" class="headerlink" title="Javascript基础学习"></a>Javascript基础学习</h2><h3 id="知识点一：let，const和var"><a href="#知识点一：let，const和var" class="headerlink" title="知识点一：let，const和var"></a>知识点一：let，const和var</h3><blockquote>
<p>使用const关键字，只需将var替换为const，就无法修改该值</p>
</blockquote>
<blockquote>
<p>不使用let后果</p>
<ul>
<li>一个变量可以使用两次var（重声明）</li>
<li>默认情况下，顶级变量是全局变量（全局对象）</li>
<li>可以在声明前使用变量（提升）</li>
<li>循环中的变量重复使用同样的引用（闭包）</li>
</ul>
<p><strong>使用let可以解决这些问题</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动装配</title>
    <url>/2020/09/11/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h1 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h1><p>自动扫描一个类，需要加这四个注解。</p>
<p><code>Controller</code>处理请求的组件</p>
<p><code>Service</code>开发业务组件</p>
<p><code>Repository</code>使用数据库的组件</p>
<p><code>Component</code>在任何地方都能使用的组件</p>
<h2 id="1-自动配置原理"><a href="#1-自动配置原理" class="headerlink" title="1.自动配置原理"></a>1.自动配置原理</h2><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</p>
<p><strong>2）、@EnableAutoConfiguration 作用：</strong></p>
<ul>
<li><pre><code>@Import({AutoConfigurationImportSelector.class})
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  利用EnableAutoConfigurationImportSelector给容器中导入一些组件</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;Java</span><br><span class="line">  protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata)</span><br></pre></td></tr></table></figure>

查看getAutoConfigurationEntry方法中的List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);

获取候选配置，进入getCandidateConfigurations方法

* ```java
  List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    扫描所有jar包类路径下  META-INF&#x2F;spring.factories</span><br><span class="line">    把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">    从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**&#x3D;&#x3D;将 类路径下  META-INF&#x2F;spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；&#x3D;&#x3D;**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;properties</span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="class">.<span class="keyword">class</span>)  //启动指定类的<span class="title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="title">HttpEncodingProperties</span>绑定起来；并把<span class="title">HttpEncodingProperties</span>加入到<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span> //<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解（<span class="title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="title">web</span>应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">CharacterEncodingFilter</span>.<span class="title">class</span>)  //判断当前项目有没有这个类<span class="title">CharacterEncodingFilter</span>；<span class="title">SpringMVC</span>中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>) //判断容器没有这个组件？</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>





<p><strong>精髓：</strong></p>
<p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p>
<p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p>
<p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p>
<p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p>
<p>xxxxAutoConfigurartion：自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
]]></content>
  </entry>
  <entry>
    <title>Spring学习过程的Bug记录</title>
    <url>/2020/08/13/Spring%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E7%9A%84Bug%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Spring学习过程的Bug记录"><a href="#Spring学习过程的Bug记录" class="headerlink" title="Spring学习过程的Bug记录"></a>Spring学习过程的Bug记录</h1><h3 id="Spring-Mybatis"><a href="#Spring-Mybatis" class="headerlink" title="Spring-Mybatis"></a>Spring-Mybatis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;sqlSessionFactory&#39; defined in class path resource [spring-dao.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.wang.mapper.UserMapper.selectUser. please check com&#x2F;wang&#x2F;mapper&#x2F;UserMapper.xml and file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]</span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;sqlSessionFactory&#39; defined in class path resource [spring-dao.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.wang.mapper.UserMapper.selectUser. please check com&#x2F;wang&#x2F;mapper&#x2F;UserMapper.xml and file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]</span><br><span class="line"></span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:874)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:879)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551)</span><br><span class="line">	at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144)</span><br><span class="line">	at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:85)</span><br><span class="line">	at MyTest.Test(MyTest.java:36)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span><br><span class="line">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)</span><br><span class="line">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)</span><br><span class="line">	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span><br><span class="line">	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span><br><span class="line">	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span><br><span class="line">	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span><br><span class="line">	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span><br><span class="line">	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span><br><span class="line">	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</span><br><span class="line">	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)</span><br><span class="line">	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)</span><br><span class="line">	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)</span><br><span class="line">	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)</span><br><span class="line">Caused by: org.springframework.core.NestedIOException: Failed to parse mapping resource: &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.wang.mapper.UserMapper.selectUser. please check com&#x2F;wang&#x2F;mapper&#x2F;UserMapper.xml and file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:596)</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.afterPropertiesSet(SqlSessionFactoryBean.java:475)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)</span><br><span class="line">	... 34 more</span><br><span class="line">Caused by: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is &#39;file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]&#39;. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.wang.mapper.UserMapper.selectUser. please check com&#x2F;wang&#x2F;mapper&#x2F;UserMapper.xml and file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:122)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.parse(XMLMapperBuilder.java:94)</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:594)</span><br><span class="line">	... 37 more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.wang.mapper.UserMapper.selectUser. please check com&#x2F;wang&#x2F;mapper&#x2F;UserMapper.xml and file [D:\Code\JAVA Code\Web\SpringStudy\spring-10-mybatis\target\classes\com\wang\mapper\UserMapper.xml]</span><br><span class="line">	at org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:947)</span><br><span class="line">	at org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:903)</span><br><span class="line">	at org.apache.ibatis.session.Configuration.addMappedStatement(Configuration.java:702)</span><br><span class="line">	at org.apache.ibatis.builder.MapperBuilderAssistant.addMappedStatement(MapperBuilderAssistant.java:297)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLStatementBuilder.parseStatementNode(XMLStatementBuilder.java:113)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildStatementFromContext(XMLMapperBuilder.java:137)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildStatementFromContext(XMLMapperBuilder.java:130)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:120)</span><br><span class="line">	... 39 more</span><br></pre></td></tr></table></figure>

<blockquote>
<p>报错原因：是我在mybatis中有这段代码删除导致spring和mybatis都扫描了一遍xml，就出错了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;com&#x2F;wang&#x2F;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure>

<p>这两段代码只要删除一段就行了，删除spring里面的或者mybatis的都行</p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC的学习</title>
    <url>/2020/08/14/SpringMVC%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SpringMVC的学习"><a href="#SpringMVC的学习" class="headerlink" title="SpringMVC的学习"></a>SpringMVC的学习</h1><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201214163829385.png" alt="image-20201214163829385"></p>
<p>Controller负责处理请求，View负责处理展示页面，Model连接这两层的数据。</p>
<p>降低了试图与业务逻辑的双向耦合。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201214164414629.png" alt="image-20201214164414629"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201214164611041.png" alt="image-20201214164611041"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201214164908576.png" alt="image-20201214164908576"></p>
<ul>
<li>MVC三层设计思想</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200814204603988.png" alt="image-20200814204603988"></p>
<p>​    Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p>​    Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，<strong>DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)</strong>。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200814204919829.png" alt="image-20200814204919829"></p>
<p>SpringMVC原理图：</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》学习笔记-Class文件的组成结构</title>
    <url>/2020/09/26/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Class%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Class-文件的组成结构"><a href="#Class-文件的组成结构" class="headerlink" title="Class 文件的组成结构"></a>Class 文件的组成结构</h1><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有任何分隔符。Java 虚拟机规范规定 Class 文件采用一种类似 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，我们之后也主要对这两种类型的数据类型进行解析。</p>
<ul>
<li><strong>无符号数：</strong> 无符号数属于基本数据类型，以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用它来描述数字、索引引用、数量值或 utf-8 编码的字符串值。</li>
<li><strong>表：</strong> 表是由多个无符号数或其他表为数据项构成的复合数据类型，名称上都以 <code>_info</code> 结尾。</li>
</ul>
<p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Class-文件的头-8-个字节"><a href="#Class-文件的头-8-个字节" class="headerlink" title="Class 文件的头 8 个字节"></a>Class 文件的头 8 个字节</h2><p>Class 文件的头 8 个字节是魔数和版本号，其中头 4 个字节是魔数，也就是 <code>0xCAFEBABE</code>，它可以用来确定这个文件是否为一个能被虚拟机接受的 Class 文件（这通过扩展名来识别文件类型要安全，毕竟扩展名是可以随便修改的）。</p>
<p>后 4 个字节则是当前 Class 文件的版本号，其中第 5、6 个字节是次版本号，第 7、8 个字节是主版本号。高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210106171445083.png" alt="image-20210106171445083"></p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>从第 9 个字节开始，就是常量池的入口，常量池是 Class 文件中：</p>
<ul>
<li>与其他项目关联最多的的数据类型；</li>
<li>占用 Class 文件空间最大的数据项目；</li>
<li>Class 文件中第一个出现的表类型数据项目。</li>
</ul>
<p>常量池的开始的两个字节，也就是第 9、10 个字节，放置一个 u2 类型的数据，标识常量池中常量的数量 cpc (constant_pool_count)，这个计数值有一个十分特殊的地方，就是它是从 1 开始而不是从 0 开始的，也就是说如果 cpc = 22，那么代表常量池中有 21 项常量，索引值为 1 ~ 21，第 0 项常量被空出来，为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”时，将让这个索引值指向 0 即可。</p>
<p>常量池中记录的是代码出现过的所有 token（类名，成员变量名等，也是我们接下来要修改的地方）以及符号引用（方法引用，成员变量引用等），主要包括以下两大类常量：</p>
<ul>
<li>字面量：</li>
</ul>
<p>  接近于 Java 语言层面的常量概念，包括</p>
<ul>
<li>文本字符串</li>
<li>声明为 final 的常量值</li>
</ul>
<ul>
<li>符号引用：</li>
</ul>
<p>  以一组符号来描述所引用的目标，包括</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中的每一项常量都通过一个表来存储。目前一共有 14 种常量，不过麻烦的地方就在于，这 14 种常量类型每一种都有自己的结构，我们在这里只详细介绍两种：CONSTANT_Class_info 和 CONSTANT_Utf8_info。</p>
<p>CONSTANT_Class_info 的存储结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... [ tag&#x3D;7 ] [ name_index ] ...</span><br><span class="line">... [  1位  ] [     2位    ] ...</span><br></pre></td></tr></table></figure>

<p>其中，tag 是标志位，用来区分常量类型的，tag = 7 就表示接下来的这个表是一个 CONSTANT_Class_info，name_index 是一个索引值，指向常量池中的一个 CONSTANT_Utf8_info 类型的常量所在的索引值，CONSTANT_Utf8_info 类型常量一般被用来描述类的全限定名、方法名和字段名。它的存储结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... [ tag&#x3D;1 ] [ 当前常量的长度 len ] [ 常量的符号引用的字符串值 ] ...</span><br><span class="line">... [  1位  ] [        2位        ] [         len位         ] ...</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>标志（tag）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>５</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>６</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>７</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>８</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>９</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="2.4 访问标志"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类文件结构?id=_24-访问标志" target="_blank" rel="noopener">2.4 访问标志</a></h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p>
<p>我们定义了一个 Employee 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="查看类的访问标志"></p>
<h3 id="2-5-当前类索引-父类索引与接口索引集合"><a href="#2-5-当前类索引-父类索引与接口索引集合" class="headerlink" title="2.5 当前类索引,父类索引与接口索引集合"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类文件结构?id=_25-当前类索引父类索引与接口索引集合" target="_blank" rel="noopener">2.5 当前类索引,父类索引与接口索引集合</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>
<h3 id="2-6-字段表集合"><a href="#2-6-字段表集合" class="headerlink" title="2.6 字段表集合"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类文件结构?id=_26-字段表集合" target="_blank" rel="noopener">2.6 字段表集合</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p><strong>字段的 access_flag 的取值:</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p>
<h3 id="2-7-方法表集合"><a href="#2-7-方法表集合" class="headerlink" title="2.7 方法表集合"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类文件结构?id=_27-方法表集合" target="_blank" rel="noopener">2.7 方法表集合</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p>
<p><strong>方法表的 access_flag 取值：</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p>
<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<h3 id="2-8-属性表集合"><a href="#2-8-属性表集合" class="headerlink" title="2.8 属性表集合"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类文件结构?id=_28-属性表集合" target="_blank" rel="noopener">2.8 属性表集合</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》学习笔记-OOM异常</title>
    <url>/2020/09/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OOM%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h2><ul>
<li>出现标志：<code>java.lang.OutOfMemoryError: Java heap space</code></li>
<li>解决方法：<ul>
<li>先通过内存映像分析工具分析 Dump 出来的堆转储快照，确认内存中的对象是否是必要的，即分清楚是出现了内存泄漏还是内存溢出；</li>
<li>如果是内存泄漏，通过工具查看泄漏对象到 GC Root 的引用链，定位出泄漏的位置；</li>
<li>如果不存在泄漏，检查虚拟机堆参数（-Xmx 和 -Xms）是否可以调大，检查代码中是否有哪些对象的生命周期过长，尝试减少程序运行期的内存消耗。</li>
</ul>
</li>
<li>虚拟机参数：<ul>
<li><code>-XX:HeapDumpOnOutOfMemoryError</code>：让虚拟机在出现内存泄漏异常时 Dump 出当前的内存堆转储快照用于事后分析。</li>
</ul>
</li>
</ul>
<h2 id="Java-虚拟机栈和本地方法栈溢出"><a href="#Java-虚拟机栈和本地方法栈溢出" class="headerlink" title="Java 虚拟机栈和本地方法栈溢出"></a>Java 虚拟机栈和本地方法栈溢出</h2><ul>
<li>单线程下，栈帧过大、虚拟机容量过小都不会导致 OutOfMemoryError，只会导致 StackOverflowError（栈会比内存先爆掉），一般多线程才会出现 OutOfMemoryError，因为线程本身要占用内存；</li>
<li>如果是多线程导致的 OutOfMemoryError，在不能减少线程数或更换 64 位虚拟机的情况，只能通过减少最大堆和减少栈容量来换取更多的线程；<ul>
<li>这个调节思路和 Java 堆出现 OOM 正好相反，Java 堆出现 OOM 要调大堆内存的设置值，而栈出现 OOM 反而要调小。</li>
</ul>
</li>
</ul>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><ul>
<li>测试思路：产生大量的类去填满方法区，直到溢出；</li>
<li>在经常动态生成大量 Class 的应用中，如 Spring 框架（使用 CGLib 字节码技术），方法区溢出是一种常见的内存溢出，要特别注意类的回收状况。</li>
</ul>
<h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><ul>
<li>出现特征：Heap Dump 文件中看不见明显异常，程序中直接或间接用了 NIO；</li>
<li>虚拟机参数：<code>-XX:MaxDirectMemorySize</code>，如果不指定，则和 <code>-Xmx</code> 一样。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》学习笔记-java内存分配策略</title>
    <url>/2020/09/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200925193425626.png" alt="image-20200925193425626"></p>
<ul>
<li>Java 内存分配策略<ul>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/03-Java内存分配策略.md#优先在-eden-区分配" target="_blank" rel="noopener">优先在 Eden 区分配</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/03-Java内存分配策略.md#大对象直接进入老年代" target="_blank" rel="noopener">大对象直接进入老年代</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/03-Java内存分配策略.md#长期存活的对象将进入老年代" target="_blank" rel="noopener">长期存活的对象将进入老年代</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/03-Java内存分配策略.md#空间分配担保" target="_blank" rel="noopener">空间分配担保</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>新生代和老年代的 GC 操作</strong></p>
<ul>
<li>新生代 GC 操作：Minor GC<ul>
<li>发生的非常频繁，速度较块。</li>
</ul>
</li>
<li>老年代 GC 操作：Full GC / Major GC<ul>
<li>经常伴随着至少一次的 Minor GC；</li>
<li>速度一般比 Minor GC 慢上 10 倍以上。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="优先在-Eden-区分配"><a href="#优先在-Eden-区分配" class="headerlink" title="优先在 Eden 区分配"></a>优先在 Eden 区分配</h2><ul>
<li>Eden 空间不够将会触发一次 Minor GC；</li>
<li>虚拟机参数：<ul>
<li><code>-Xmx</code>：Java 堆的最大值；</li>
<li><code>-Xms</code>：Java 堆的最小值；</li>
<li><code>-Xmn</code>：新生代大小；</li>
<li><code>-XX:SurvivorRatio=8</code>：Eden 区 / Survivor 区 = 8 : 1</li>
</ul>
</li>
</ul>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><ul>
<li><p><strong>大对象定义：</strong> 需要大量连续内存空间的 Java 对象。例如那种很长的字符串或者数组。</p>
</li>
<li><p>设置对象直接进入老年代大小限制：</p>
<ul>
<li><pre><code>-XX:PretenureSizeThreshold</code></pre><p>：单位是字节；</p>
<ul>
<li>只对 Serial 和 ParNew 两款收集器有效。</li>
</ul>
</li>
<li><p><strong>目的：</strong> 因为新生代采用的是复制算法收集垃圾，大对象直接进入老年代可以避免在 Eden 区和 Survivor 区发生大量的内存复制（新生代采用复制算法收集内存）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><ul>
<li><strong>固定对象年龄判定：</strong> 虚拟机给每个对象定义一个年龄计数器，对象每在 Survivor 中熬过一次 Minor GC，年龄 +1，达到 <code>-XX:MaxTenuringThreshold</code> 设定值后，会被晋升到老年代，<code>-XX:MaxTenuringThreshold</code> 默认为 15；</li>
<li><strong>动态对象年龄判定：</strong> Survivor 中有相同年龄的对象的空间总和大于 Survivor 空间的一半，那么，年龄大于或等于该年龄的对象直接晋升到老年代。</li>
<li></li>
</ul>
<blockquote>
<p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>
</blockquote>
<p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>我们知道，新生代采用的是复制算法清理内存，每一次 Minor GC，虚拟机会将 Eden 区和其中一块 Survivor 区的存活对象复制到另一块 Survivor 区，但 <strong>当出现大量对象在一次 Minor GC 后仍然存活的情况时，Survivor 区可能容纳不下这么多对象，此时，就需要老年代进行分配担保，即将 Survivor 无法容纳的对象直接进入老年代。</strong></p>
<p>这么做有一个前提，就是老年代得装得下这么多对象。可是在一次 GC 操作前，虚拟机并不知道到底会有多少对象存活，所以空间分配担保有这样一个判断流程：</p>
<ul>
<li>发生 Minor GC 前，虚拟机先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间；<ul>
<li>如果大于，Minor GC 一定是安全的；</li>
<li>如果小于，虚拟机会查看 HandlePromotionFailure 参数，看看是否允许担保失败；<ul>
<li>允许失败：尝试着进行一次 Minor GC；</li>
<li>不允许失败：进行一次 Full GC；</li>
</ul>
</li>
</ul>
</li>
<li>不过 JDK 6 Update 24 后，HandlePromotionFailure 参数就没有用了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC。</li>
</ul>
<h2 id="Metaspace-元空间与-PermGen-永久代"><a href="#Metaspace-元空间与-PermGen-永久代" class="headerlink" title="Metaspace 元空间与 PermGen 永久代"></a>Metaspace 元空间与 PermGen 永久代</h2><p>Java 8 彻底将永久代 (PermGen) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。</p>
<p><strong>移除 PermGen 的原因：</strong></p>
<ul>
<li>PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM；</li>
<li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
</ul>
<p><strong>移除 PermGen 后，方法区和字符串常量的位置：</strong></p>
<ul>
<li>方法区：移至 Metaspace；</li>
<li>字符串常量：移至 Java Heap。</li>
</ul>
<p><strong>Metaspace 的位置：</strong> 本地堆内存(native heap)。</p>
<p><strong>Metaspace 的优点：</strong> 永久代 OOM 问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上 Metaspace 就可以有多大；</p>
<p><strong>JVM参数：</strong></p>
<ul>
<li><code>-XX:MetaspaceSize</code>：分配给类元数据空间（以字节计）的初始大小，为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><code>-XX:MaxMetaspaceSize</code>：分配给类元数据空间的最大值，超过此值就会触发Full GC，取决于系统内存的大小。JVM会动态地改变此值。</li>
<li><code>-XX:MinMetaspaceFreeRatio</code>：一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li>
<li><code>-XX:MaxMetaspaceFreeRatio</code>：一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li>
</ul>
<p><strong>总结：</strong></p>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》学习笔记-垃圾收集GC</title>
    <url>/2020/09/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86GC/</url>
    <content><![CDATA[<p>垃圾收集（Garbage Collection，GC），它的任务是解决以下 3 件问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>其中第一个问题很好回答，在 Java 中，GC 主要发生在 Java 堆和方法区中，对于后两个问题，我们将在之后的内容中进行讨论，并介绍 HotSpot 的 7 个垃圾收集器。</p>
<ul>
<li>垃圾收集 (GC)<ul>
<li>判断对象的生死<ul>
<li>判断对象是否可用的算法<ul>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#引用计数算法" target="_blank" rel="noopener">引用计数算法</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#可达性分析算法主流" target="_blank" rel="noopener">可达性分析算法（主流）</a></li>
</ul>
</li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#四种引用类型" target="_blank" rel="noopener">四种引用类型</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#宣告对象死亡的两次标记过程" target="_blank" rel="noopener">宣告对象死亡的两次标记过程</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#方法区的回收" target="_blank" rel="noopener">方法区的回收</a></li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#基础标记---清除算法" target="_blank" rel="noopener">基础：标记 - 清除算法</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#解决效率问题复制算法" target="_blank" rel="noopener">解决效率问题：复制算法</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#解决空间碎片问题标记---整理算法" target="_blank" rel="noopener">解决空间碎片问题：标记 - 整理算法</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#进化分代收集算法" target="_blank" rel="noopener">进化：分代收集算法</a></li>
</ul>
</li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#hotspot-中-gc-算法的实现" target="_blank" rel="noopener">HotSpot 中 GC 算法的实现</a></li>
<li>7 个垃圾收集器<ul>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#serial--parnew-搭配-serial-old-收集器" target="_blank" rel="noopener">Serial / ParNew 搭配 Serial Old 收集器</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#parallel-搭配-parallel-scavenge-收集器" target="_blank" rel="noopener">Parallel 搭配 Parallel Scavenge 收集器</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#cms-收集器" target="_blank" rel="noopener">CMS 收集器</a></li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#g1-收集器" target="_blank" rel="noopener">G1 收集器</a></li>
</ul>
</li>
<li><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/02-垃圾收集(GC).md#gc-日志解读" target="_blank" rel="noopener">GC 日志解读</a></li>
</ul>
</li>
</ul>
<h2 id="判断对象的生死"><a href="#判断对象的生死" class="headerlink" title="判断对象的生死"></a>判断对象的生死</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924154338847.png" alt="image-20200924154338847"></p>
<p>什么时候回收对象？当然是这个对象再也不会被用到的时候回收。所以要想解决 “什么时候回收？” 这个问题，我们要先能判断一个对象什么时候什么时候真正的 “死” 掉了，判断对象是否可用主要有以下两种方法。</p>
<h3 id="判断对象是否可用的算法"><a href="#判断对象是否可用的算法" class="headerlink" title="判断对象是否可用的算法"></a>判断对象是否可用的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li>算法描述：<ul>
<li>给对象添加一个引用计数器；</li>
<li>每有一个地方引用它，计数器加 1；</li>
<li>引用失效时，计数器减 1；</li>
<li>计数器值为 0 的对象不再可用。</li>
</ul>
</li>
<li>缺点：<ul>
<li>很难解决循环引用的问题。即 <code>objA.instance = objB; objB.instance = objA;</code>，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。</li>
</ul>
</li>
</ul>
<h4 id="可达性分析算法（主流）"><a href="#可达性分析算法（主流）" class="headerlink" title="可达性分析算法（主流）"></a>可达性分析算法（主流）</h4><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210106141150869.png" alt="image-20210106141150869"></p>
<ul>
<li>算法描述：<ul>
<li>从 “GC Root” 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；</li>
<li>从 “GC Root” 开始，不可达的对象被判为不可用。</li>
</ul>
</li>
<li>Java 中可作为 “GC Root” 的对象：<ul>
<li>栈中（本地变量表中的reference）<ul>
<li>虚拟机栈中，栈帧中的本地变量表引用的对象；</li>
<li>本地方法栈中，JNI 引用的对象（native方法）；</li>
</ul>
</li>
<li>方法区中<ul>
<li>类的静态属性引用的对象；</li>
<li>常量引用的对象；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。</p>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>JDK 1.2 后，Java 中才有了后 3 种引用的实现。</p>
<ul>
<li><p><strong>强引用：</strong> 像 <code>Object obj = new Object()</code> 这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
<li><p><strong>软引用：</strong> 用来引用还存在但非必须的对象。对于软引用对象，在 OOM 前，虚拟机会把这些对象列入回收范围中进行第二次回收，如果这次回收后，内存还是不够用，就 OOM。实现类：<code>SoftReference</code>。</p>
</li>
<li><p><strong>弱引用：</strong> 强度比软引用更弱一些，被弱引用引用的对象只能生存到下一次垃圾收集前，一旦发生垃圾收集，被弱引用所引用的对象就会被清掉。实现类：<code>WeakReference</code>。</p>
</li>
<li><p><strong>虚引用：</strong> 幽灵引用，对对象没有半毛钱影响，甚至不能用来取得一个对象的实例。它唯一的用途就是：当被一个虚引用引用的对象被回收时，系统会收到这个对象被回收了的通知。实现类：<code>PhantomReference</code>。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动。</strong></p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
</li>
</ul>
<p>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<h3 id="宣告对象死亡的两次标记过程"><a href="#宣告对象死亡的两次标记过程" class="headerlink" title="宣告对象死亡的两次标记过程"></a>宣告对象死亡的两次标记过程</h3><ul>
<li>当发现对象不可达后，该对象被第一次标记，并进行是否有必要执行<strong>finalize()</strong>方法的判断；<ul>
<li>不需要执行：对象没有覆盖 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已被执行过（<code>finalize()</code> 只被执行一次）；</li>
<li>需要执行：将该对象放置在一个F-Queue队列中，稍后由一个虚拟机自动创建的低优先级线程Finalizer执行。</li>
</ul>
</li>
<li><code>finalize()</code> 方法是对象逃脱死亡的最后一次机会，不过虚拟机不保证等待 <code>finalize()</code> 方法执行结束，也就是说，虚拟机只触发 <code>finalize()</code> 方法的执行，如果这个方法要执行超久，那么虚拟机并不等待它执行结束，所以最好不要用这个方法。</li>
<li><code>finalize()</code> 方法能做的，try-finally 都能做，所以忘了这个方法吧！</li>
</ul>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>永久代的 GC 主要回收：<strong>废弃常量</strong> 和 <strong>无用的类</strong>。</p>
<ul>
<li>废弃常量：例如一个字符串 “abc”，当没有任何引用指向 “abc” 时，它就是废弃常量了。</li>
<li>无用的类：同时满足以下 3 个条件的类。<ul>
<li>该类的所有实例已被回收，Java 堆中不存在该类的任何实例；</li>
<li>加载该类的 Classloader 已被回收；</li>
<li>该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924155408710.png" alt="image-20200924155408710"></p>
<h3 id="基础：标记-清除算法"><a href="#基础：标记-清除算法" class="headerlink" title="基础：标记 - 清除算法"></a>基础：标记 - 清除算法</h3><ul>
<li>算法描述：<ul>
<li>先标记出所有需要回收的对象（图中深色区域）；</li>
<li>标记完后，统一回收所有被标记对象（留下狗啃似的可用内存区域……）。</li>
</ul>
</li>
<li>不足：<ul>
<li>效率问题：标记和清理两个过程的效率都不高。</li>
<li>空间碎片问题：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java内存管理机制/pic/标记清除GC算法.png" target="_blank" rel="noopener"><img src="https://github.com/TangBean/understanding-the-jvm/raw/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/pic/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4GC%E7%AE%97%E6%B3%95.png" alt="标记清除GC算法.png"></a></p>
<h3 id="解决效率问题：复制算法"><a href="#解决效率问题：复制算法" class="headerlink" title="解决效率问题：复制算法"></a>解决效率问题：复制算法</h3><ul>
<li><strong>算法描述：</strong><ul>
<li>将可用内存分为大小相等的两块，每次只使用其中一块；</li>
<li>当一块内存用完时，将这块内存上还存活的对象复制到另一块内存上去，将这一块内存全部清理掉。</li>
</ul>
</li>
<li><strong>不足：</strong> 可用内存缩小为原来的一半，适合GC过后只有少量对象存活的新生代。</li>
<li><strong>节省内存的方法：</strong><ul>
<li>新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分；</li>
<li>把内存划分为：<ul>
<li>1 块比较大的 Eden 区；</li>
<li>2 块较小的 Survivor 区；</li>
</ul>
</li>
<li>每次使用 Eden 区和 1 块 Survivor 区；</li>
<li>回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空；</li>
<li>JVM 参数设置：<code>-XX:SurvivorRatio=8</code> 表示 <code>Eden 区大小 / 1 块 Survivor 区大小 = 8</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924160529916.png" alt="image-20200924160529916"></p>
<h3 id="解决空间碎片问题：标记-整理算法"><a href="#解决空间碎片问题：标记-整理算法" class="headerlink" title="解决空间碎片问题：标记 - 整理算法"></a>解决空间碎片问题：标记 - 整理算法</h3><ul>
<li>算法描述：<ul>
<li>标记方法与 “标记 - 清除算法” 一样；</li>
<li>标记完后，将所有存活对象向一端移动，然后直接清理掉边界以外的内存。</li>
</ul>
</li>
<li><strong>不足：</strong> 存在效率问题，适合老年代。</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924161806550.png" alt="image-20200924161806550"></p>
<h3 id="进化：分代收集算法"><a href="#进化：分代收集算法" class="headerlink" title="进化：分代收集算法"></a>进化：分代收集算法</h3><ul>
<li><strong>新生代：</strong> GC 过后只有少量对象存活 —— <strong>复制算法</strong></li>
<li><strong>老年代：</strong> GC 过后对象存活率高 —— <strong>标记 - 整理算法或者标记-清理算法</strong></li>
</ul>
<h2 id="HotSpot-中-GC-算法的实现"><a href="#HotSpot-中-GC-算法的实现" class="headerlink" title="HotSpot 中 GC 算法的实现"></a>HotSpot 中 GC 算法的实现</h2><p>通过前两小节对于判断对象生死和垃圾收集算法的介绍，我们已经对虚拟机是进行 GC 的流程有了一个大致的了解。但是，在 HotSpot 虚拟机中，高效的实现这些算法也是一个需要考虑的问题。所以，接下来，我们将研究一下 HotSpot 虚拟机到底是如何高效的实现这些算法的，以及在实现中有哪些需要注意的问题。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924162603185.png" alt="image-20200924162603185"></p>
<p>通过之前的分析，GC 算法的实现流程简单的来说分为以下两步：</p>
<ol>
<li>找到死掉的对象；</li>
<li>把它清了。</li>
</ol>
<p>想要找到死掉的对象，我们就要进行可达性分析，也就是从 GC Root 找到引用链的这个操作。</p>
<p>也就是说，进行可达性分析的第一步，就是要<strong><u>枚举 GC Roots</u></strong>，这就需要虚拟机知道哪些地方存放着对象应用。如果每一次枚举 GC Roots 都需要把整个栈上位置都遍历一遍，那可就费时间了，毕竟并不是所有位置都存放在引用呀。所以为了提高 GC 的效率，HotSpot 使用了一种 OopMap 的数据结构，<strong>OopMap 记录了栈上本地变量到堆上对象的引用关系</strong>，也就是说，GC 的时候就不用遍历整个栈只遍历每个栈的 OopMap 就行了。</p>
<p>在 OopMap 的帮助下，HotSpot 可以快速准确的完成 GC 枚举了，不过，OopMap 也不是万年不变的，它也是需要被更新的，当内存中的对象间的引用关系发生变化时，就需要改变 OopMap 中的相应内容。可是能导致引用关系发生变化的指令非常之多，如果我们执行完一条指令就改下 OopMap，这 GC 成本实在太高了。</p>
<p>因此，HotSpot 采用了一种在 <u><strong>“安全点”</strong></u> 更新 OopMap 的方法，安全点的选取既不能让 GC 等待的时间过长，也不能过于频繁增加运行负担，也就是说，我们既要让程序运行一段时间，又不能让这个时间太长。我们知道，JVM 中每条指令执行的是很快的，所以一个超级长的指令流也可能很快就执行完了，所以 <strong>真正会出现 “长时间执行” 的一般是指令的复用，例如：方法调用、循环跳转、异常跳转等</strong>，虚拟机一般会将这些地方设置为安全点更新 OopMap 并判断是否需要进行 GC 操作。</p>
<p>此外，在进行枚举根节点的这个操作时，为了保证准确性，我们需要在一段时间内 “冻结” 整个应用，即 Stop The World（传说中的 GC 停顿），因为如果在我们分析可达性的过程中，对象的引用关系还在变来变去，那是不可能得到正确的分析结果的。即便是在号称几乎不会发生停顿的 CMS 垃圾收集器中，枚举根节点时也是必须要停顿的。这里就涉及到了一个问题：</p>
<p><strong>我们让所有线程跑到最近的安全点再停顿下来进行 GC 操作呢？</strong></p>
<p>主要有以下两种方式：</p>
<ul>
<li><p>抢先式中断：（几乎不用）</p>
<ul>
<li>先中断所有线程；</li>
<li>发现有线程没中断在安全点，恢复它，让它跑到安全点。</li>
</ul>
</li>
<li><p>主动式中断：(主要使用)</p>
<ul>
<li>设置一个中断标记；</li>
</ul>
<ul>
<li>每个线程到达安全点时，检查这个中断标记，选择是否中断自己。</li>
</ul>
</li>
</ul>
<p>除此安全点之外，还有一个叫做 <strong><u>“安全区域”</u></strong> 的东西，一个一直在执行的线程可以自己 “走” 到安全点去，可是一个处于 Sleep 或者 Blocked 状态的线程是没办法自己到达安全点中断自己的，我们总不能让 GC 操作一直等着这些个 ”不执行“ 的线程重新被分配资源吧。对于这种情况，我们要依靠安全区域来解决。</p>
<p><strong>安全区域是指在一段代码片段之中，引用关系不会发生变化，因此在这个区域中的任意位置开始 GC 都是安全的。</strong></p>
<p>当线程执行到安全区域时，它会把自己标识为 Safe Region，这样 JVM 发起 GC 时是不会理会这个线程的。当这个线程要离开安全区域时，它会检查系统是否在 GC 中，如果不在，它就继续执行，如果在，它就等 GC 结束再继续执行。</p>
<p>本小节我们主要讲述 HotSpot 虚拟机是如何发起内存回收的，也就是如何找到死掉的对象，至于如何清掉这些个对象，HotSpot 将其交给了一堆叫做 ”GC 收集器“ 的东西，这东西又有好多种，不同的 GC 收集器的处理方式不同，适用的场景也不同，我们将在下一小节进行详细讲述。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p> 讲解分代收集理论的时候，提到了为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。<br>记忆集是一种用于记录从<strong>非收集区域指向收集区域的指针集合</strong>的抽象数据结构。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构，如代码清单3-5所示：</p>
<p>​                        以对象指针来实现记忆集的伪代码</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924164211448.png" alt="image-20200924164211448"></p>
<p>这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>第三种“卡精度”所指的是用一种称为“<strong>卡表”</strong>（Card Table）的方式去实现记忆集[1]，这也是目前<strong>最常用</strong>的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。<br>卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。以下这行代码是HotSpot默认的卡表标记逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CARD_TABLE [this address &gt;&gt; 9] &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块<strong>特定大小的内存块</strong>，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即<strong>512字节</strong>（地址右移9位，相当于用地址除以512）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块[4]，如图3-5所示。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924164557817.png" alt="image-20200924164557817"></p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为<strong>这个元素变脏（Dirty）</strong>，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><h3 id="并发的-可达性分析"><a href="#并发的-可达性分析" class="headerlink" title="并发的 可达性分析"></a>并发的 可达性分析</h3><h2 id="7-个垃圾收集器"><a href="#7-个垃圾收集器" class="headerlink" title="7 个垃圾收集器"></a>7 个垃圾收集器</h2><p>垃圾收集器就是内存回收操作的具体实现，HotSpot 里足足有 7 种，为啥要弄这么多，因为它们各有各的适用场景。有的属于新生代收集器，有的属于老年代收集器，所以一般是搭配使用的（除了万能的 G1）。关于它们的简单介绍以及分类请见下图。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924163400493.png" alt="image-20200924163400493"></p>
<h3 id="Serial-ParNew-搭配-Serial-Old-收集器"><a href="#Serial-ParNew-搭配-Serial-Old-收集器" class="headerlink" title="Serial / ParNew 搭配 Serial Old 收集器"></a>Serial / ParNew 搭配 Serial Old 收集器</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924164947674.png" alt="image-20200924164947674"></p>
<p>Serial 收集器是虚拟机在 Client 模式下的默认新生代收集器，它的优势是简单高效，在单 CPU 模式下很牛。</p>
<p>ParNew 收集器就是 Serial 收集器的多线程版本，虽然除此之外没什么创新之处，但它却是许多运行在 Server 模式下的虚拟机中的首选新生代收集器，因为除了 Serial 收集器外，只有它能和 CMS 收集器（第一款真正意义上的支持并发的垃圾收集器）搭配使用。</p>
<h3 id="Parallel-搭配-Parallel-Scavenge-收集器"><a href="#Parallel-搭配-Parallel-Scavenge-收集器" class="headerlink" title="Parallel 搭配 Parallel Scavenge 收集器"></a>Parallel 搭配 Parallel Scavenge 收集器</h3><p>首先，这俩货肯定是要搭配使用的，不仅仅如此，它俩还贼特别，它们的关注点与其他收集器不同，其他收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目的是达到一个可控的吞吐量。</p>
<blockquote>
<p>吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )</p>
</blockquote>
<p>因此，Parallel Scavenge 收集器不管是新生代还是老年代都是多个线程同时进行垃圾收集，十分适合于应用在注重吞吐量以及 CPU 资源敏感的场合。</p>
<p>可调节的虚拟机参数：</p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code>：最大 GC 停顿的秒数；</li>
<li><code>-XX:GCTimeRatio</code>：吞吐量大小，一个 0 ~ 100 的数，<code>最大 GC 时间占总时间的比率 = 1 / (GCTimeRatio + 1)</code>；</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：一个开关参数，打开后就无需手工指定 <code>-Xmn</code>，<code>-XX:SurvivorRatio</code> 等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，自行调整。<strong>垃圾收集的自适应的调节策略（GC Ergonomics）</strong> 区别与ParNew收集器的一个重要特征</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924171330386.png" alt="image-20200924171330386"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924171348779.png" alt="image-20200924171348779"></p>
<p><strong>参数设置：</strong></p>
<ul>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：在 CMS 要进行 Full GC 时进行内存碎片整理（默认开启）（<strong>Java9中已经废弃</strong>）</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：在多少次 Full GC 后进行一次空间整理（默认是 0，即每一次 Full GC 后都进行一次空间整理）（<strong>Java9中已经废弃</strong>）</li>
</ul>
<blockquote>
<p><strong>关于 CMS 使用 标记 - 清除 算法的一点思考：</strong></p>
<p>之前对于 CMS 为什么要采用 标记 - 清除 算法十分的不理解，既然已经有了看起来更高级的 标记 - 整理 算法，那 CMS 为什么不用呢？最近想了想，感觉可能是这个原因，不过也不是很确定，只是个人的一种猜测。</p>
<p>标记 - 整理 会将所有存活对象向一端移动，然后直接清理掉边界以外的内存。这就意味着需要一个指针来维护这个分隔存活对象和无用空间的点，而我们知道 CMS 是并发清理的，虽然我们启动了多个线程进行垃圾回收，不过如果使用 标记 - 整理 算法，为了保证线程安全，在整理时要对那个分隔指针加锁，保证同一时刻只有一个线程能修改它，<strong>加锁的这一过程相当于将并行的清理过程变成了串行的，也就失去了并行清理的意义了。</strong></p>
<p>所以，CMS 采用了 标记 - 清除 算法。</p>
</blockquote>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924173552243.png" alt="image-20200924173552243"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924173609615.png" alt="image-20200924173609615"></p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<ul>
<li><p><strong>整体上使用标记-整理算法，对于Region来说使用复制算法</strong></p>
</li>
<li><p>可预测停顿时间**</p>
</li>
<li><p>和CMS比最大的优势，可以将停顿时间控制在根据使用者设定的时间**</p>
<ul>
<li><strong>G1跟踪各个Region里垃圾的价值大小(回收需要的时间和释放的空间)，后台维护一个优先列表</strong></li>
</ul>
</li>
</ul>
<h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><h2 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h2><h2 id="GC-日志解读"><a href="#GC-日志解读" class="headerlink" title="GC 日志解读"></a>GC 日志解读</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924173629358.png" alt="image-20200924173629358"></p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》学习笔记-java内存结构</title>
    <url>/2020/09/21/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="《深入理解java虚拟机》学习笔记-java内存结构"><a href="#《深入理解java虚拟机》学习笔记-java内存结构" class="headerlink" title="《深入理解java虚拟机》学习笔记-java内存结构"></a>《深入理解java虚拟机》学习笔记-java内存结构</h1><p>本章介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象及可能产生的问题</p>
<h2 id="JVM-运行时的数据区域"><a href="#JVM-运行时的数据区域" class="headerlink" title="JVM 运行时的数据区域"></a>JVM 运行时的数据区域</h2><p>首先获取一个直观的认识：</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200921152714596.png" alt="image-20200921152714596"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210105153308941.png" alt="image-20210105153308941"></p>
<p>总共也就这么 5 个区（直接内存不属于 JVM 运行时数据区的一部分），除了程序计数器其他的地方都有可能出现 OOM (OutOfMemoryError)，其中像是程序计数器和两个栈（Java 虚拟机栈 &amp; 本地方法栈）都是每个线程要有一个的，所以肯定是线程隔离的。而其他 2 个区就是线程共享的了，也就是说，如果有多个线程要同时访问这两个区的数据，是会出现线程安全问题的。接下来，我们将对这些区域进行详细的介绍。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来确定下一条要执行的字节码指令的位置</li>
<li>执行 Java 方法和 native 方法时的区别：<ul>
<li>执行 Java 方法时：记录虚拟机正在执行的字节码指令地址；</li>
<li>执行 native 方法时：无定义；</li>
</ul>
</li>
<li>是 5 个区域中唯一不会出现 OOM 的区域。</li>
</ul>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><ul>
<li><p>Java 方法执行的内存模型，每个方法执行的过程，就是它所对应的栈帧在虚拟机栈中入栈到出栈的过程；</p>
</li>
<li><p>Java虚拟机栈是由一个个栈帧组成，而每个栈帧都拥有：局部变量表，操作数栈，动态链接，方法出口信息。</p>
</li>
<li><p>服务于 Java 方法；</p>
</li>
<li><p>可能抛出的异常：</p>
<ul>
<li>OutOfMemoryError（在虚拟机栈可以动态扩展的情况下，扩展时无法申请到足够的内存）；</li>
<li>StackOverflowError（线程请求的栈深度 &gt; 虚拟机所允许的深度）；</li>
</ul>
</li>
<li><p>虚拟机参数设置：<code>-Xss</code>.</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3></li>
<li><p>服务于 native 方法；</p>
</li>
<li><p>可能抛出的异常：与 Java 虚拟机栈一样。</p>
</li>
</ul>
<h3 id="Java-堆（GC堆）"><a href="#Java-堆（GC堆）" class="headerlink" title="Java 堆（GC堆）"></a>Java 堆（GC堆）</h3><ul>
<li>唯一的目的：存放对象实例（现在没那么绝对）；从jdk1.7开始已经默认开启了逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</li>
<li>垃圾收集器管理的主要区域；</li>
<li>可以处于物理上不连续的内存空间中，逻辑上是连续的；</li>
<li>可能抛出的异常：<ul>
<li>OutOfMemoryError（堆中没有内存可以分配给新创建的实例，并且堆也无法再继续扩展了）。</li>
<li>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：<ol>
<li><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li>
</ol>
</li>
</ul>
</li>
<li>虚拟机参数设置：<ul>
<li>最大值：<code>-Xmx</code></li>
<li>最小值：<code>-Xms</code></li>
<li>两个参数设置成相同的值可避免堆自动扩展。</li>
</ul>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</p>
<ul>
<li>类信息：即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。</li>
</ul>
</li>
<li><p>垃圾收集行为在此区域很少发生（主要针对常量池的回收和对类型的卸载）；</p>
<ul>
<li>不过也不能不清理，对于经常动态生成大量 Class 的应用，如 Spring 等，需要特别注意类的回收状况。</li>
</ul>
</li>
<li><p><strong>运行时常量池</strong>也是方法区的一部分；</p>
<ul>
<li>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量（就是代码中定义的 static final 常量）和符号引用，这部分信息就存储在运行时常量池中。</li>
<li>JDK1.7之前，运行时常量池在方法区中，1.7的时候将字符串常量池拿到了堆中，剩下的还在方法区中，1.8的时候用元空间取代了永久代，字符串常量池还在堆中，运行时常量池还在方法区中，也就是在元空间里。</li>
</ul>
</li>
<li><p>可能抛出的异常：</p>
<ul>
<li>OutOfMemoryError（方法区无法满足内存分配需求时）。</li>
</ul>
</li>
<li><p>JDK 1.8 的时候，方法区（<strong>HotSpot 的永久代）被彻底移除了</strong>（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<blockquote>
<p>为什么要将永久代替换为元空间？</p>
<ol>
<li><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
</li>
</ol>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<ol start="2">
<li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="方法区和永久代的区别"><a href="#方法区和永久代的区别" class="headerlink" title="方法区和永久代的区别"></a>方法区和永久代的区别</h4><p>很像Java中接口和类的关系，永久代是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。其它虚拟机没有永久代这种说法。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li><p>JDK 1.4 的 NIO 类可以使用 native 函数库直接分配堆外内存，这是一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它在 Java 堆中存储一个 DirectByteBuffer 对象作为堆外内存的引用，这样就可以对堆外内存进行操作了。因为可以避免 Java 堆和 Native 堆之间来回复制数据，在一些场景可以带来显著的性能提高。</p>
</li>
<li><p>虚拟机参数设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize</span><br></pre></td></tr></table></figure>

<ul>
<li>默认等于 Java 堆最大值，即 <code>-Xmx</code> 指定的值。</li>
</ul>
</li>
<li><p>将直接内存放在这里讲解的原因是它也可能会出现 OutOfMemoryError；</p>
<ul>
<li>服务器管理员在配置 JVM 参数时，会根据机器的实际内存设置 <code>-Xmx</code> 等信息，但经常会忽略直接内存（默认等于 <code>-Xmx</code> 设置值），这可能会使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现 OOM。</li>
</ul>
</li>
</ul>
<h3 id="JVM老年代和新生代"><a href="#JVM老年代和新生代" class="headerlink" title="JVM老年代和新生代"></a>JVM老年代和新生代</h3><p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。<br>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。<br>堆的内存模型大致为：</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200924161533188.png" alt="image-20200924161533188"></p>
<p>从图中可以看出： <strong>堆大小 = 新生代 + 老年代。</strong>其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，<strong>Eden : from : to = 8 : 1 : 1</strong> ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。<br><strong>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务</strong>，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p>
<h2 id="HotSpot-虚拟机堆中的对象"><a href="#HotSpot-虚拟机堆中的对象" class="headerlink" title="HotSpot 虚拟机堆中的对象"></a>HotSpot 虚拟机堆中的对象</h2><p>这一小节将对 JVM 对 Java 堆中的对象的创建、布局和访问的全过程进行讲解。</p>
<h3 id="对象的创建（遇到一条-new-指令时）"><a href="#对象的创建（遇到一条-new-指令时）" class="headerlink" title="对象的创建（遇到一条 new 指令时）"></a>对象的创建（遇到一条 new 指令时）</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210105160130645.png" alt="image-20210105160130645"></p>
<ol>
<li><p>检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先把这个类加载进内存；</p>
</li>
<li><p>类加载检查通过后，虚拟机将为新对象分配内存，此时已经可以确定存储这个对象所需的内存大小；</p>
<ul>
<li><p>分配内存的方式：</p>
<p>指针碰撞和空闲列表-&gt;Java堆是否规整决定-&gt;垃圾收集器是否带有压缩整理功能决定（GC收集器的算法是“标记-清除”还是“标记-整理”）</p>
</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210105160820852.png" alt="image-20210105160820852"></p>
</li>
<li><p>在堆中为新对象分配可用内存；</p>
</li>
<li><p>将分配到的内存初始化（赋零值）；·</p>
</li>
<li><p>设置对象头中的数据；</p>
</li>
<li><p>此时，从虚拟机的角度看，对象已经创建好了，但从 Java 程序的角度看，对象创建才刚刚开始，构造函数还没有执行。</p>
</li>
</ol>
<p>第 3 步，在堆中为新对象分配可用内存时，会涉及到以下两个问题：</p>
<p><strong>如何在堆中为新对象划分可用的内存？</strong></p>
<ul>
<li>指针碰撞（内存分配规整）<ul>
<li>用过的内存放一边，没用过的内存放一边，中间用一个指针分隔；</li>
<li>分配内存的过程就是将指针向没用过的内存那边移动所需的长度；</li>
</ul>
</li>
<li>空闲列表（内存分配不规整）<ul>
<li>维护一个列表，记录哪些内存块是可用的；</li>
<li>分配内存时，从列表上选取一块足够大的空间分给对象，并更新列表上的记录；</li>
</ul>
</li>
</ul>
<p><strong>如何处理多线程创建对象时，划分内存的指针的同步问题？</strong></p>
<ul>
<li>对分配内存空间的动作进行同步处理（CAS）；CAS+失败重试</li>
<li>把内存分配动作按照线程划分在不同的空间之中进行；<ul>
<li>每个线程在 Java 堆中Eden区预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）；</li>
<li>哪个线程要分配内存就在哪个线程的 TLAB 上分配，TLAB 用完需要分配新的 TLAB 时，才需要同步锁定；</li>
<li>通过 <code>-XX:+/-UseTLAB</code> 参数设定是否使用 TLAB。</li>
</ul>
</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul>
<li>对象头：<ul>
<li>第一部分：存储对象自身运行时的数据，HashCode、GC分代年龄等（Mark Word）；</li>
<li>第二部分：类型指针，指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例（HotSpot 采用的是直接指针的方式访问对象的）；</li>
<li>如果是个数组对象，对象头中还有一块用于记录数组长度的数据。</li>
</ul>
</li>
<li>实例数据：<ul>
<li>默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；</li>
<li>默认分配顺序下，父类字段会被分配在子类字段前面。</li>
</ul>
</li>
</ul>
<p><em>注：HotSpot VM要求对象的起始地址必须是8字节的整数倍，所以不够要补齐。</em></p>
<h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>Java 程序需要通过虚拟机栈上的 reference 数据来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：句柄访问和直接指针访问。</p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>句柄访问会在 Java 堆中划分一块内存作为句柄池，每一个句柄存放着到对象实例数据和对象类型数据的指针。</p>
<p>优势：对象移动的时候（这在垃圾回收时十分常见）只需改变句柄池中对象实例数据的指针，不需要修改reference本身。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200921180031407.png" alt="image-20200921180031407"></p>
<h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><p>直接指针访问方式在 Java 堆对象的实例数据中存放了一个指向对象类型数据的指针，在 HotSpot 中，这个指针会被存放在对象头中。</p>
<p>优势：减少了一次指针定位对象实例数据的开销，速度更快。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200921180120209.png" alt="image-20200921180120209"></p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》学习笔记-虚拟机的类加载机制</title>
    <url>/2020/09/26/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？</p>
<ul>
<li>主动引用<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：<ul>
<li>使用 new 实例化对象；</li>
<li>读取或设置一个类的 static 字段（被 final 修饰的除外）；</li>
<li>调用类的静态方法。</li>
</ul>
</li>
<li>对类进行反射调用；</li>
<li>初始化一个类时，其父类还没初始化（需先初始化父类）；<ul>
<li>这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。</li>
</ul>
</li>
<li>虚拟机启动，先初始化包含 main() 函数的主类；</li>
<li>JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic。</li>
<li>一个接口定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，这个接口的实现类发生了初始化，那该接口要再其之前被初始化。</li>
</ul>
</li>
<li>被动引用<ul>
<li>通过子类引用父类静态字段，不会导致子类初始化；</li>
<li><code>Array[] arr = new Array[10];</code> 不会触发 Array 类初始化；</li>
<li><code>static final VAR</code> 在编译阶段会存入调用类的常量池，通过 <code>ClassName.VAR</code> 引用不会触发 ClassName 初始化。</li>
</ul>
</li>
</ul>
<p>也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。</p>
<h2 id="类的显式加载和隐式加载"><a href="#类的显式加载和隐式加载" class="headerlink" title="类的显式加载和隐式加载"></a>类的显式加载和隐式加载</h2><ul>
<li>显示加载：<ul>
<li>调用 <code>ClassLoader#loadClass(className)</code> 或 <code>Class.forName(className)</code>。</li>
<li>两种显示加载 .class 文件的区别：<ul>
<li><code>Class.forName(className)</code> 加载 class 的同时会初始化静态域，<code>ClassLoader#loadClass(className)</code> 不会初始化静态域；</li>
<li>Class.forName 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。</li>
</ul>
</li>
</ul>
</li>
<li>隐式加载：<ul>
<li>new 类对象；</li>
<li>使用类的静态域；</li>
<li>创建子类对象；</li>
<li>使用子类的静态域；</li>
<li>其他的隐式加载，在 JVM 启动时：<ul>
<li>BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；</li>
<li>ExtClassLoader 会加载指定目录下一些特殊的 Class；</li>
<li>AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加载 --&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化 --&gt; 使用 --&gt; 卸载</span><br><span class="line">       |&lt;------- 连接 -------&gt;|</span><br><span class="line">|&lt;------------- 类加载 ----------------&gt;|</span><br></pre></td></tr></table></figure>

<p>类的生命周期一共有 7 个阶段，其中前五个阶段较为重要，统称为类加载，第 2 ~ 4 阶段统称为连接，加载和连接中的三个过程开始的顺序是固定的，但是执行过程中是可以交叉执行的。接下来，我们将对类加载的 5 个阶段进行一一讲解。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="加载的-3-个阶段"><a href="#加载的-3-个阶段" class="headerlink" title="加载的 3 个阶段"></a>加载的 3 个阶段</h4><ul>
<li>通过类的全限定名获取二进制字节流（将 .class 文件读进内存）；</li>
<li>将字节流的静态存储结构转化为方法区的运行时的数据结构；</li>
<li>在内存中生成该类的 Class 对象；<ul>
<li>HotSpot 虚拟机把这个对象放在方法区，非 Java 堆。</li>
</ul>
</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>非数组类<ul>
<li>系统提供的引导类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
</li>
<li>数组类<ul>
<li>不通过类加载器，由 Java 虚拟机直接创建</li>
<li>创建动作由 newarray 指令触发，new 实际上触发了 <code>[L全类名</code> 对象的初始化</li>
<li>规则<ul>
<li>数组元素是引用类型<ul>
<li>加载：递归加载其组件</li>
<li>可见性：与引用类型一致</li>
</ul>
</li>
<li>数组元素是非引用类型<ul>
<li>加载：与引导类加载器关联</li>
<li>可见性：public</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li><strong>目的：</strong> 确保 .class 文件中的字节流信息符合虚拟机的要求。</li>
<li>4 个验证过程：<ul>
<li>文件格式验证：是否符合 Class 文件格式规范，保证输入的字节流能正确的解析并存储于方法区之内，验证文件开头 4 个字节是不是 “魔数” <code>0xCAFEBABE</code>，主次版本号是否在当前虚拟机的处理范围之内，常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析），类的元数据信息进行了语义校验。例如：这个类是否有父类，这个类是否继承了不允许继承的类。</li>
<li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）。比如保证任意时刻操作数和指令代码序列都能配合工作。</li>
<li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验</li>
</ul>
</li>
<li>这个操作虽然重要，但不是必要的，可以通过 <code>-Xverify:none</code> 关掉。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p><strong>描述：</strong> 为 static 变量在方法区分配内存。仅包括类变量，不包括实例变量，实例变量会在对象实例化的时候随着对象一块分配在java堆中。</p>
</li>
<li><p>static 变量准备后的初始值：</p>
<ul>
<li><pre><code>public static int value = 123;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 准备后为 0，value 的赋值指令 putstatic 会被放在 &#96;&lt;clinit&gt;()&#96; 方法中，&#96;&lt;clinit&gt;()&#96;方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
public static final int value = 123;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 准备后为 123，因为被 &#96;static final&#96; 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。</span><br><span class="line"></span><br><span class="line">### 解析</span><br><span class="line"></span><br><span class="line">- 描述：</span><br><span class="line"></span><br><span class="line">  将常量池中的 “符号引用” 替换为 “直接引用”。也就是得到类或者字段、方法在内存中的指针或者偏移量。</span><br><span class="line"></span><br><span class="line">  - 在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</span><br><span class="line">  - 什么是 “符号引用” 和 “直接引用” ？</span><br><span class="line">    - 符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</span><br><span class="line">    - 直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**解析过程**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 初始化</span><br><span class="line"></span><br><span class="line">- **描述：** 执行类构造器 &#96;&lt;clinit&gt;()&#96; 方法的过程。</span><br><span class="line">- 只有以下五种情况，必须对类进行初始化。</span><br><span class="line">  * 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</span><br><span class="line">    - 当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</span><br><span class="line">    - 当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</span><br><span class="line">    - 当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</span><br><span class="line">    - 当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</span><br><span class="line">  * 使用 &#96;java.lang.reflect&#96; 包的方法对类进行反射调用时如Class.forname(&quot;...&quot;),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</span><br><span class="line">  * 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</span><br><span class="line">  * 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</span><br><span class="line">  * MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</span><br><span class="line">  * **「补充，来自[issue745](https:&#x2F;&#x2F;github.com&#x2F;Snailclimb&#x2F;JavaGuide&#x2F;issues&#x2F;745)」** 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</span><br><span class="line">- &#96;&lt;clinit&gt;()&#96; 方法。</span><br><span class="line">  - 包含的内容：</span><br><span class="line"></span><br><span class="line">    - 所有 static 的赋值操作；</span><br><span class="line">    - static 块中的语句；</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;clinit&gt;()&#96;方法中的语句顺序：</span><br><span class="line">    - 基本按照语句在源文件中出现的顺序排列；</span><br><span class="line">    - 静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。</span><br><span class="line"></span><br><span class="line">  - 与&#96;&lt;init&gt;()&#96;的不同：</span><br><span class="line"></span><br><span class="line">    - 不需要显示调用父类的 &#96;&lt;clinit&gt;()&#96; 方法；</span><br><span class="line"></span><br><span class="line">    - 虚拟机保证在子类的&#96;&lt;clinit&gt;()&#96;方法执行前，父类的&#96;&lt;clinit&gt;()&#96;方法一定执行完毕。也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。</span><br><span class="line"></span><br><span class="line">  - 接口与类的不同：</span><br><span class="line"></span><br><span class="line">    - 执行子接口的 &#96;&lt;clinit&gt;()&#96; 方法前不需要先执行父接口的 &#96;&lt;clinit&gt;()&#96; 方法（除非用到了父接口中定义的 public static final 变量）；</span><br><span class="line"></span><br><span class="line">  - 执行过程中加锁：</span><br><span class="line"></span><br><span class="line">    - 同一时刻只能有一个线程在执行 &#96;&lt;clinit&gt;()&#96; 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。所以，在多线程环境下进行初始化的话可能会引起死锁，并且这种死锁很难发现。</span><br><span class="line"></span><br><span class="line">  - 非必要性：</span><br><span class="line"></span><br><span class="line">    - 一个类如果没有任何 static 的内容就不需要执行 &#96;&lt;clinit&gt;()&#96; 方法。</span><br><span class="line"></span><br><span class="line">*注：初始化时，才真正开始执行类中定义的 Java 代码。*</span><br><span class="line"></span><br><span class="line">### 卸载</span><br><span class="line"></span><br><span class="line">卸载类即该类的Class对象被GC。</span><br><span class="line"></span><br><span class="line">卸载类需要满足3个要求:</span><br><span class="line"></span><br><span class="line">1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</span><br><span class="line">2. 该类没有在其他任何地方被引用</span><br><span class="line">3. 该类的类加载器的实例已被GC</span><br><span class="line"></span><br><span class="line">所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</span><br><span class="line"></span><br><span class="line">只要想通一点就好了，jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</span><br><span class="line"></span><br><span class="line">## 类加载器</span><br><span class="line"></span><br><span class="line">### 如何判断两个类 “相等”</span><br><span class="line"></span><br><span class="line">- “相等” 的要求</span><br><span class="line">  - 同一个 .class 文件</span><br><span class="line">  - 被同一个虚拟机加载</span><br><span class="line">  - 被同一个类加载器加载</span><br><span class="line">- 判断 “相等” 的方法</span><br><span class="line">  - &#96;instanceof&#96; 关键字</span><br><span class="line">  - Class 对象中的方法：</span><br><span class="line">    - &#96;equals()&#96;</span><br><span class="line">    - &#96;isInstance()&#96;</span><br><span class="line">    - &#96;isAssignableFrom()&#96;</span><br><span class="line"></span><br><span class="line">### 类加载器的分类</span><br><span class="line"></span><br><span class="line">- 启动类加载器（Bootstrap）：最顶层的加载类，由C++实现，加载：</span><br><span class="line">  - &lt;JAVA_HOME&gt;&#x2F;lib目录下</span><br><span class="line">  - -Xbootclasspath 参数指定的路径</span><br><span class="line">- 扩展类加载器（Extension）</span><br><span class="line">  - &lt;JAVA_HOME&gt;&#x2F;lib&#x2F;ext</span><br><span class="line">  - java.ext.dirs 系统变量指定的路径</span><br><span class="line">- 应用程序类加载器（Application）</span><br><span class="line">  - -classpath 参数</span><br><span class="line"></span><br><span class="line">### 双亲委派模型</span><br><span class="line"></span><br><span class="line">每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 &#96;loadClass()&#96; 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 &#96;BootstrapClassLoader&#96; 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 &#96;BootstrapClassLoader&#96; 作为父类加载器。</span><br><span class="line"></span><br><span class="line">![image-20210107155044866](https:&#x2F;&#x2F;gitee.com&#x2F;Hardendless&#x2F;blogImg&#x2F;raw&#x2F;master&#x2F;img&#x2F;image-20210107155044866.png)</span><br><span class="line"></span><br><span class="line">- 工作过程</span><br><span class="line">  - 当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器</span><br><span class="line">    - 因此，所有的类加载请求，都会先被传送到启动类加载器</span><br><span class="line">  - 只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载</span><br><span class="line">  </span><br><span class="line">- 实现</span><br><span class="line">  - 检查该类是否已经被加载</span><br><span class="line">  - 将类加载请求委派给父类</span><br><span class="line">    - 如果父类加载器为 null，默认使用启动类加载器</span><br><span class="line">    - &#96;parent.loadClass(name, false)&#96;</span><br><span class="line">  - 当父类加载器加载失败时</span><br><span class="line">    - catch ClassNotFoundException 但不做任何处理</span><br><span class="line">    - 调用自己的 findClass() 去加载</span><br><span class="line">      - 我们在实现自己的类加载器时只需要 &#96;extends ClassLoader&#96;，然后重写 &#96;findClass()&#96; 方法而不是 &#96;loadClass()&#96; 方法，这样就不用重写 &#96;loadClass()&#96; 中的双亲委派机制了</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  private final ClassLoader parent; </span><br><span class="line">  protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">          throws ClassNotFoundException</span><br><span class="line">      &#123;</span><br><span class="line">          synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">              &#x2F;&#x2F; 首先，检查请求的类是否已经被加载过</span><br><span class="line">              Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">              if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                  long t0 &#x3D; System.nanoTime();</span><br><span class="line">                  try &#123;</span><br><span class="line">                      if (parent !&#x3D; null) &#123;&#x2F;&#x2F;父加载器不为空，调用父加载器loadClass()方法处理</span><br><span class="line">                          c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                      &#125; else &#123;&#x2F;&#x2F;父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span><br><span class="line">                          c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                     &#x2F;&#x2F;抛出异常说明父类加载器无法完成加载请求</span><br><span class="line">                  &#125;</span><br><span class="line">  </span><br><span class="line">                  if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                      long t1 &#x3D; System.nanoTime();</span><br><span class="line">                      &#x2F;&#x2F;自己尝试加载</span><br><span class="line">                      c &#x3D; findClass(name);</span><br><span class="line">  </span><br><span class="line">                      &#x2F;&#x2F; this is the defining class loader; record the stats</span><br><span class="line">                      sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                      sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                      sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              if (resolve) &#123;</span><br><span class="line">                  resolveClass(c);</span><br><span class="line">              &#125;</span><br><span class="line">              return c;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>


</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>优点</p>
<ul>
<li>自己写的类库同名类不会覆盖类库的类,避免了重复加载。</li>
</ul>
</li>
</ul>
<h3 id="不想使用双亲委派模型的话"><a href="#不想使用双亲委派模型的话" class="headerlink" title="不想使用双亲委派模型的话"></a>不想使用双亲委派模型的话</h3><p>自己定义一个类加载器，<strong>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</strong></p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>Mybatis中Communications link failure错误</title>
    <url>/2020/07/22/%E4%B8%BA%E4%BB%80%E4%B9%88useSSL=true%20%E5%86%99true%20%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E6%94%B9%E6%88%90false%20%E5%B0%B1%E5%8F%AF%E4%BB%A5/</url>
    <content><![CDATA[<h2 id="为什么useSSL-true-写true-会报错，改成false-就可以"><a href="#为什么useSSL-true-写true-会报错，改成false-就可以" class="headerlink" title="为什么useSSL=true 写true 会报错，改成false 就可以"></a>为什么useSSL=true 写true 会报错，改成false 就可以</h2><blockquote>
<p>MySQL在高版本需要指明是否进行SSL连接<br>SSL协议提供服务主要：<br>       1）认证用户服务器，确保数据发送到正确的服务器； 　　 .<br>       2）加密数据，防止数据传输途中被窃取使用；<br>       3）维护数据完整性，验证数据在传输过程中是否丢失；</p>
<p>JDBC在与数据库连接时，JDBC与MySQL版本不兼容，MySQL的版本高一些</p>
</blockquote>
<p>Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification</p>
<p>不建议在没有服务器身份验证的情况下建立SSL连接。根据MySQL 5.5.45+、5.6.26+和5.7.6+的要求，如果不设置显式选项，则必须建立默认的SSL连接。您需要通过设置useSSL=false显式地禁用SSL，或者设置useSSL=true并为服务器证书验证提供信任存储</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 09.用两个栈实现队列</title>
    <url>/2020/07/19/%E5%89%91%E6%8C%87offer-t25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="剑指offer-t25合并两个排序列表"><a href="#剑指offer-t25合并两个排序列表" class="headerlink" title="剑指offer-t25合并两个排序列表"></a>剑指offer-t25合并两个排序列表</h1><p><strong>题目</strong>：</p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
<p><strong>我自己的题解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &gt; l2.val)&#123;</span><br><span class="line">                listNode.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    listNode.next = l1;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> listNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确题解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dum &#x3D; new ListNode(0), cur &#x3D; dum;</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">            if(l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur.next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next &#x3D; l1 !&#x3D; null ? l1 : l2;</span><br><span class="line">        return dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="学到的知识点："><a href="#学到的知识点：" class="headerlink" title="学到的知识点："></a>学到的知识点：</h4><ol>
<li>伪头节点的使用，可以解决我的答案中的如何设置头节点的问题，最后直接返回dum.next就行。</li>
<li>定义一个链表，还需要一个指向它的链表</li>
</ol>
<h2 id="递归，给跪了"><a href="#递归，给跪了" class="headerlink" title="递归，给跪了"></a>递归，给跪了</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoLists3(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       if (l1 &#x3D;&#x3D; null) return l2;</span><br><span class="line">       if (l2 &#x3D;&#x3D; null) return l1;</span><br><span class="line"></span><br><span class="line">       if (l1.val &lt; l2.val) &#123;</span><br><span class="line"></span><br><span class="line">           l1.next &#x3D; mergeTwoLists1(l1.next, l2);</span><br><span class="line">           return l1;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           l2.next &#x3D; mergeTwoLists1(l1, l2.next);</span><br><span class="line">           return l2;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 09.用两个栈实现队列</title>
    <url>/2020/07/19/%E5%89%91%E6%8C%87offer%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09.用两个栈实现队列"></a>剑指offer 09.用两个栈实现队列</h2><ul>
<li><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.add(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>如果你使用Stack的方式来做这道题，会造成速度较慢； 原因的话是Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。 但是我的意思不是像100%代码那样直接使用一个LinkedList当做队列，那确实是快，但是不符题意。 贴上代码，这样的优化之后，效率提高了40%，超过97% 。</strong></p>
<blockquote>
<p>解题思路：两个栈实现队列，A直接进栈实现<strong>队尾加元素</strong>，A栈全部出栈到B栈然后输出B中的第一个元素就实现了<strong>删除队首元素</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer18.删除链表的节点</title>
    <url>/2020/07/27/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="双指针问题"><a href="#双指针问题" class="headerlink" title="双指针问题"></a>双指针问题</h2><ul>
<li>什么是双指针？</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer12</title>
    <url>/2020/07/09/%E5%89%91%E6%8C%87offer12/</url>
    <content><![CDATA[<h2 id="剑指offer12"><a href="#剑指offer12" class="headerlink" title="剑指offer12"></a>剑指offer12</h2><blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 1：</p>
<p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：</p>
<p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false</p>
</blockquote>
<hr>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><blockquote>
<p>典型的矩阵搜索问题 ，使用深度优先搜索以及剪纸解决</p>
</blockquote>
<h5 id="算法的原理"><a href="#算法的原理" class="headerlink" title="算法的原理"></a>算法的原理</h5><ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dfs(int step)</span><br><span class="line">&#123;</span><br><span class="line">	判断边界</span><br><span class="line">	尝试每一种可能 for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		继续下一步 dfs(step+1);</span><br><span class="line">	&#125;</span><br><span class="line">	返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（<em>例如：此矩阵元素和目标字符不同、此元素已被访问）</em>，则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
</ul>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><ul>
<li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li>
<li>终止条件：<br>返回 falsefalse ： ① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。<br>返回 truetrue ： 字符串 word 已全部匹配，即 k = len(word) - 1 。</li>
<li>递推工作：<ol>
<li>标记当前矩阵元素： 将 board[i][j] 值暂存于变量 tmp ，并修改为字符 ‘/‘ ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需一条可行路径） ，并记录结果至 res 。</li>
<li>还原当前矩阵元素： 将 tmp 暂存值还原至 board[i][j] 元素。</li>
</ol>
</li>
<li>回溯返回值： 返回 res ，代表是否搜索到目标字符串。</li>
</ul>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><blockquote>
<p><em>M</em>,<em>N</em> 分别为矩阵行列大小， K<em>K</em> 为字符串 <code>word</code> 长度。</p>
</blockquote>
<ul>
<li>时间复杂度 O(3^KMN)O(3 ^K<br> MN) ： 最差情况下，需要遍历矩阵中长度为 KK 字符串的所有方案，时间复杂度为 O(3^K)O(3 ^K )；矩阵中共有 MNMN 个起点，时间复杂度为 O(MN)O(MN) 。<br>方案数计算： 设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 33 种选择，因此方案数的复杂度为 O(3^K)O(3 ^K) 。</li>
<li>空间复杂度 O(K)O(K) ： 搜索过程中的递归深度不超过 KK ，因此系统因函数调用累计使用的栈空间占用 O(K)O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MNK=MN ，递归深度为 MNMN ，此时系统栈使用 O(MN)O(MN) 的额外空间。</li>
</ul>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        char[] words &#x3D; word.toCharArray();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">                if(dfs(board, words, i, j, 0)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean dfs(char[][] board, char[] word, int i, int j, int k) &#123;</span><br><span class="line">        if(i &gt;&#x3D; board.length || i &lt; 0 || j &gt;&#x3D; board[0].length || j &lt; 0 || board[i][j] !&#x3D; word[k]) return false;</span><br><span class="line">        if(k &#x3D;&#x3D; word.length - 1) return true;</span><br><span class="line">        char tmp &#x3D; board[i][j];</span><br><span class="line">        board[i][j] &#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">        boolean res &#x3D; dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || </span><br><span class="line">                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);</span><br><span class="line">        board[i][j] &#x3D; tmp;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小的知识点"><a href="#小的知识点" class="headerlink" title="小的知识点"></a>小的知识点</h5><p>字符转字符数组 char[] words = word.toCharArray();</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-线性回归</title>
    <url>/2020/09/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="2-1-损失函数"><a href="#2-1-损失函数" class="headerlink" title="2.1 损失函数"></a>2.1 损失函数</h3><p>总损失定义为：</p>
<ul>
<li>y_i为第i个训练样本的真实值</li>
<li>h(x_i)为第i个训练样本特征值组合预测函数</li>
<li>又称最小二乘法</li>
</ul>
<p><strong>如何去减少这个损失，使我们预测的更加准确些？既然存在了这个损失，我们一直说机器学习有自动学习的功能，在线性回归这里更是能够体现。这里可以通过一些优化方法去优化（其实是数学当中的求导功能）回归的总损失！！！</strong></p>
<h2 id="2-2-优化算法"><a href="#2-2-优化算法" class="headerlink" title="2.2 优化算法"></a>2.2 优化算法</h2><p><strong>如何去求模型当中的W，使得损失最小？（目的是找到最小损失对应的W值）</strong></p>
<p>线性回归经常使用的两种优化算法</p>
<ul>
<li>正规方程</li>
</ul>
<blockquote>
<p>理解：X为特征值矩阵，y为目标值矩阵。直接求到最好的结果</p>
<p>缺点：当特征过多过复杂时，求解速度太慢并且得不到结果</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>第六章 接口、lambda表达式与内部类</title>
    <url>/2020/08/15/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章 接口、lambda表达式与内部类"></a>第六章 接口、lambda表达式与内部类</h1>]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2020/12/09/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201209200611625.png" alt="image-20201209200611625"></p>
<p>4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看firewall服务状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"># 开启、重启、关闭、firewalld.service服务</span><br><span class="line"># 开启</span><br><span class="line">service firewalld start</span><br><span class="line"># 重启</span><br><span class="line">service firewalld restart</span><br><span class="line"># 关闭</span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"># 查看防火墙规则</span><br><span class="line">firewall-cmd --list-all    # 查看全部信息</span><br><span class="line">firewall-cmd --list-ports  # 只看端口信息</span><br><span class="line"></span><br><span class="line"># 开启端口</span><br><span class="line">开端口命令：firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone #作用域</span><br><span class="line">--add-port&#x3D;80&#x2F;tcp  #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">--permanent   #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>冒泡排序和希尔排序</title>
    <url>/2020/11/26/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="冒泡排序和希尔排序"><a href="#冒泡排序和希尔排序" class="headerlink" title="冒泡排序和希尔排序"></a>冒泡排序和希尔排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201125160731337.png" alt="image-20201125160731337"></p>
<p>实现冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; data.length; i ++)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//arr[n - i, n]已排好序</span></span><br><span class="line">           <span class="comment">//通过冒泡在arr[n - i - 1]位置放上合适的元素</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (data[j].compareTo(data[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                   swap(data, j, j + <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(E[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">       E t = data[i];</span><br><span class="line">       data[i] = data[j];</span><br><span class="line">       data[j] = t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//针对完全有序的数组进行的优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; data.length; i ++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//arr[n - i, n]已排好序</span></span><br><span class="line">            <span class="comment">//通过冒泡在arr[n - i - 1]位置放上合适的元素</span></span><br><span class="line">            <span class="keyword">boolean</span> isSwaped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (data[j].compareTo(data[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    swap(data, j, j + <span class="number">1</span>);</span><br><span class="line">                    isSwaped = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isSwaped)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再优化，寻找最后一次交换位置的后面那个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort3</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; data.length;)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//arr[n - i, n]已排好序</span></span><br><span class="line">            <span class="comment">//通过冒泡在arr[n - i - 1]位置放上合适的元素</span></span><br><span class="line">            <span class="keyword">boolean</span> isSwaped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> lastSwappedIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (data[j].compareTo(data[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    swap(data, j, j + <span class="number">1</span>);</span><br><span class="line">                    lastSwappedIndex = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = data.length - lastSwappedIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基本思想： 让数组越来越有序</p>
<p>不能只处理相邻的逆序对</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201125171638077.png" alt="image-20201125171638077"></p>
<ul>
<li>希尔排序的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> h = data.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; h; start ++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start + h; i &lt; data.length; i += h)&#123;</span><br><span class="line"></span><br><span class="line">                    E t = data[i];</span><br><span class="line">                    <span class="keyword">int</span> j;</span><br><span class="line">                    <span class="keyword">for</span> (j = i; j - h &gt;= <span class="number">0</span> &amp;&amp; t.compareTo(data[j - h]) &lt; <span class="number">0</span>; j -= h)&#123;</span><br><span class="line">                        data[j] = data[j - h];</span><br><span class="line">                    &#125;</span><br><span class="line">                    data[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            h /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201125221818328.png" alt="image-20201125221818328"></p>
<p>实测希尔排序慢与O(n*logn)，远快于O(n * 2)</p>
<h3 id="优化希尔排序"><a href="#优化希尔排序" class="headerlink" title="优化希尔排序"></a>优化希尔排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> h = data.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对data[h, n),进行插入排序</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; data.length; i ++)&#123;</span><br><span class="line"></span><br><span class="line">               E t = data[i];</span><br><span class="line">               <span class="keyword">int</span> j;</span><br><span class="line">               <span class="keyword">for</span> (j = i; j - h &gt;= <span class="number">0</span> &amp;&amp; t.compareTo(data[j - h]) &lt; <span class="number">0</span>; j -= h)&#123;</span><br><span class="line">                   data[j] = data[j - h];</span><br><span class="line">               &#125;</span><br><span class="line">               data[j] = t;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">            h /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201125222741650.png" alt="image-20201125222741650"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort3</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (h &lt; data.length)</span><br><span class="line">            h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对data[h, n),进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; data.length; i ++)&#123;</span><br><span class="line"></span><br><span class="line">                E t = data[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i; j - h &gt;= <span class="number">0</span> &amp;&amp; t.compareTo(data[j - h]) &lt; <span class="number">0</span>; j -= h)&#123;</span><br><span class="line">                    data[j] = data[j - h];</span><br><span class="line">                &#125;</span><br><span class="line">                data[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法的稳定性"><a href="#算法的稳定性" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201126193550623.png" alt="image-20201126193550623"></p>
<ol>
<li>选择排序是不稳定的</li>
<li>插入排序是稳定的</li>
<li>希尔排序是不稳定的</li>
<li>冒泡排序稳定</li>
<li>快速排序不稳定</li>
<li>堆排序不稳定</li>
<li>归并排序是稳定的</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>AVL树和红黑树</title>
    <url>/2020/12/04/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="AVL树和红黑树"><a href="#AVL树和红黑树" class="headerlink" title="AVL树和红黑树"></a>AVL树和红黑树</h1><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>平衡二叉树：对任意一个节点，左子树和右子树的高度差不能超过1</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203142012482.png" alt="image-20201203142012482"></p>
<p>平衡因子：左右子树的高度差</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203142456358.png" alt="image-20201203142456358"></p>
<h3 id="左旋转和右旋转"><a href="#左旋转和右旋转" class="headerlink" title="左旋转和右旋转"></a>左旋转和右旋转</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203221610374.png" alt="image-20201203221610374"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203222346406.png" alt="image-20201203222346406"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203222647761.png" alt="image-20201203222647761"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203222937612.png" alt="image-20201203222937612"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203223007048.png" alt="image-20201203223007048"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203223108477.png" alt="image-20201203223108477"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201203223142185.png" alt="image-20201203223142185"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>和二分搜索树一样的删除操作，只不过过程中需要考虑二分搜索树是否会因为删除操作而变得不平衡。如过不平衡的话，采取和添加节点一样的操作，来使得这个平衡二叉树变得平衡。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            height = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该二叉树是否是一棵二分搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;K&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, keys);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; keys.size() ; i ++)</span><br><span class="line">            <span class="keyword">if</span>(keys.get(i - <span class="number">1</span>).compareTo(keys.get(i)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node, ArrayList&lt;K&gt; keys)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inOrder(node.left, keys);</span><br><span class="line">        keys.add(node.key);</span><br><span class="line">        inOrder(node.right, keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该二叉树是否是一棵平衡二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断以Node为根的二叉树是否是一棵平衡二叉树，递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(balanceFactor) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(node.left) &amp;&amp; isBalanced(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得节点node的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得节点node的平衡因子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对节点y进行向右旋转操作，返回旋转后新的根节点x</span></span><br><span class="line">    <span class="comment">//        y                              x</span></span><br><span class="line">    <span class="comment">//       / \                           /   \</span></span><br><span class="line">    <span class="comment">//      x   T4     向右旋转 (y)        z     y</span></span><br><span class="line">    <span class="comment">//     / \       - - - - - - - -&gt;    / \   / \</span></span><br><span class="line">    <span class="comment">//    z   T3                       T1  T2 T3 T4</span></span><br><span class="line">    <span class="comment">//   / \</span></span><br><span class="line">    <span class="comment">// T1   T2</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">        Node x = y.left;</span><br><span class="line">        Node T3 = x.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向右旋转过程</span></span><br><span class="line">        x.right = y;</span><br><span class="line">        y.left = T3;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新height</span></span><br><span class="line">        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对节点y进行向左旋转操作，返回旋转后新的根节点x</span></span><br><span class="line">    <span class="comment">//    y                             x</span></span><br><span class="line">    <span class="comment">//  /  \                          /   \</span></span><br><span class="line">    <span class="comment">// T1   x      向左旋转 (y)       y     z</span></span><br><span class="line">    <span class="comment">//     / \   - - - - - - - -&gt;   / \   / \</span></span><br><span class="line">    <span class="comment">//   T2  z                     T1 T2 T3 T4</span></span><br><span class="line">    <span class="comment">//      / \</span></span><br><span class="line">    <span class="comment">//     T3 T4</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">        Node x = y.right;</span><br><span class="line">        Node T2 = x.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左旋转过程</span></span><br><span class="line">        x.left = y;</span><br><span class="line">        y.right = T2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新height</span></span><br><span class="line">        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向二分搜索树中添加新的元素(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        root = add(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的二分搜索树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新height</span></span><br><span class="line">        node.height = <span class="number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算平衡因子</span></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平衡维护</span></span><br><span class="line">        <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LR</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RL</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line"></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node retNode;</span><br><span class="line">        <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.left = remove(node.left , key);</span><br><span class="line">            <span class="comment">// return node;</span></span><br><span class="line">            retNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            <span class="comment">// return node;</span></span><br><span class="line">            retNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="comment">// return rightNode;</span></span><br><span class="line">                retNode = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="comment">// return leftNode;</span></span><br><span class="line">                retNode = leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">                <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">                Node successor = minimum(node.right);</span><br><span class="line">                <span class="comment">//successor.right = removeMin(node.right);</span></span><br><span class="line">                successor.right = remove(node.right, successor.key);</span><br><span class="line">                successor.left = node.left;</span><br><span class="line"></span><br><span class="line">                node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// return successor;</span></span><br><span class="line">                retNode = successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(retNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新height</span></span><br><span class="line">        retNode.height = <span class="number">1</span> + Math.max(getHeight(retNode.left), getHeight(retNode.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算平衡因子</span></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(retNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平衡维护</span></span><br><span class="line">        <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LR</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            retNode.left = leftRotate(retNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RL</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retNode.right = rightRotate(retNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Pride and Prejudice"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(FileOperation.readFile(<span class="string">"pride-and-prejudice.txt"</span>, words)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Total words: "</span> + words.size());</span><br><span class="line"></span><br><span class="line">            AVLTree&lt;String, Integer&gt; map = <span class="keyword">new</span> AVLTree&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.contains(word))</span><br><span class="line">                    map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    map.add(word, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Total different words: "</span> + map.getSize());</span><br><span class="line">            System.out.println(<span class="string">"Frequency of PRIDE: "</span> + map.get(<span class="string">"pride"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Frequency of PREJUDICE: "</span> + map.get(<span class="string">"prejudice"</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"is BST : "</span> + map.isBST());</span><br><span class="line">            System.out.println(<span class="string">"is Balanced : "</span> + map.isBalanced());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(String word: words)&#123;</span><br><span class="line">                map.remove(word);</span><br><span class="line">                <span class="keyword">if</span>(!map.isBST() || !map.isBalanced())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204193606558.png" alt="image-20201204193606558"></p>
<p>红黑树与2-3树是等价的。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204194214954.png" alt="image-20201204194214954"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204201029327.png" alt="image-20201204201029327"></p>
<p>2-3树绝不添加到空的位置。</p>
<h3 id="红黑树和2-3树的联系"><a href="#红黑树和2-3树的联系" class="headerlink" title="红黑树和2-3树的联系"></a>红黑树和2-3树的联系</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204202003623.png" alt="image-20201204202003623"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204202043299.png" alt="image-20201204202043299"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204202132200.png" alt="image-20201204202132200"></p>
<p>特殊的边，把边的定义放到了节点中。</p>
<p>所有红色的节点都是向左倾斜的。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204202320048.png" alt="image-20201204202320048"></p>
<h3 id="红黑树的基本性质和时间复杂度"><a href="#红黑树的基本性质和时间复杂度" class="headerlink" title="红黑树的基本性质和时间复杂度"></a>红黑树的基本性质和时间复杂度</h3><p>红黑树是保持“黑平衡”的二叉树。严格意义上，不是平衡二叉树。</p>
<p>最大高度2logn， 时间复杂度O（logn）。</p>
<h3 id="红黑树添加新元素"><a href="#红黑树添加新元素" class="headerlink" title="红黑树添加新元素"></a>红黑树添加新元素</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204210038315.png" alt="image-20201204210038315"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204210121704.png" alt="image-20201204210121704"></p>
<p>维护的时机：和AVL树一样</p>
<p>添加节点后回溯向上维护</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201204211416013.png" alt="image-20201204211416013"></p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点node的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   node                     x</span></span><br><span class="line">    <span class="comment">//  /   \     左旋转         /  \</span></span><br><span class="line">    <span class="comment">// T1   x   ---------&gt;   node   T3</span></span><br><span class="line">    <span class="comment">//     / \              /   \</span></span><br><span class="line">    <span class="comment">//    T2 T3            T1   T2</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//     node                   x</span></span><br><span class="line">    <span class="comment">//    /   \     右旋转       /  \</span></span><br><span class="line">    <span class="comment">//   x    T2   -------&gt;   y   node</span></span><br><span class="line">    <span class="comment">//  / \                       /  \</span></span><br><span class="line">    <span class="comment">// y  T1                     T1  T2</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 颜色翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向红黑树中添加新的元素(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        root = add(root, key, value);</span><br><span class="line">        root.color = BLACK; <span class="comment">// 最终根节点为黑色节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的红黑树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后红黑树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value); <span class="comment">// 默认插入红色节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line"></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.left = remove(node.left , key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Pride and Prejudice"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(FileOperation.readFile(<span class="string">"pride-and-prejudice.txt"</span>, words)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Total words: "</span> + words.size());</span><br><span class="line"></span><br><span class="line">            RBTree&lt;String, Integer&gt; map = <span class="keyword">new</span> RBTree&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.contains(word))</span><br><span class="line">                    map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    map.add(word, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Total different words: "</span> + map.getSize());</span><br><span class="line">            System.out.println(<span class="string">"Frequency of PRIDE: "</span> + map.get(<span class="string">"pride"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Frequency of PREJUDICE: "</span> + map.get(<span class="string">"prejudice"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>二分搜索树</title>
    <url>/2020/11/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h1><h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201113154610512.png" alt="image-20201113154610512"></p>
<h2 id="二叉树的重要性"><a href="#二叉树的重要性" class="headerlink" title="二叉树的重要性"></a>二叉树的重要性</h2><p>比如经典的排序算法，快速排序可以看作是二叉树的前序遍历，归并排序可以看作是二叉树的后续遍历。</p>
<p>快速排序的逻辑是，若要对<code>nums[lo..hi]</code>进行排序，我们先找一个分界点<code>p</code>，通过交换元素使得<code>nums[lo..p-1]</code>都小于等于<code>nums[p]</code>，且<code>nums[p+1..hi]</code>都大于<code>nums[p]</code>，然后递归地去<code>nums[lo..p-1]</code>和<code>nums[p+1..hi]</code>中寻找新的分界点，最后整个数组就被排序了。</p>
<p>快速排序的代码框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void sort(int[] nums, int lo, int hi) &#123;</span><br><span class="line">    &#x2F;****** 前序遍历位置 ******&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 通过交换元素构建分界点 p</span><br><span class="line">    int p &#x3D; partition(nums, lo, hi);</span><br><span class="line">    &#x2F;************************&#x2F;</span><br><span class="line"></span><br><span class="line">    sort(nums, lo, p - 1);</span><br><span class="line">    sort(nums, p + 1, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？</p>
<p>再说说归并排序的逻辑，若要对<code>nums[lo..hi]</code>进行排序，我们先对<code>nums[lo..mid]</code>排序，再对<code>nums[mid+1..hi]</code>排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p>
<p>归并排序的代码框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void sort(int[] nums, int lo, int hi) &#123;</span><br><span class="line">    int mid &#x3D; (lo + hi) &#x2F; 2;</span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    sort(nums, mid + 1, hi);</span><br><span class="line"></span><br><span class="line">    &#x2F;****** 后序遍历位置 ******&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 合并两个排好序的子数组</span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    &#x2F;************************&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。</p>
<h2 id="递归算法的秘诀"><a href="#递归算法的秘诀" class="headerlink" title="递归算法的秘诀"></a>递归算法的秘诀</h2><p><strong>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归</strong>。</p>
<p>比如说让你计算一棵二叉树共有几个节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义：count(root) 返回以 root 为根的树有多少节点</span><br><span class="line">int count(TreeNode root) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    if (root &#x3D;&#x3D; null) return 0;</span><br><span class="line">    &#x2F;&#x2F; 自己加上子树的节点数就是整棵树的节点数</span><br><span class="line">    return 1 + count(root.left) + count(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>root</code>本身就是一个节点，加上左右子树的节点数就是以<code>root</code>为根的树的节点总数。</p>
<p>左右子树的节点数怎么算？其实就是计算根为<code>root.left</code>和<code>root.right</code>两棵树的节点数呗，按照定义，递归调用<code>count</code>函数即可算出来。</p>
<p><strong>写树相关的算法，简单说就是，先搞清楚当前<code>root</code>节点该做什么，然后根据函数定义递归调用子节点</strong>，递归调用会让孩子节点做相同的事情。</p>
<p><strong>递归函数的基本写法：</strong></p>
<ol>
<li>求解最基本的问题</li>
<li>把原问题转化成更小的问题</li>
</ol>
<h2 id="二分搜索树-1"><a href="#二分搜索树-1" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201113154838691.png" alt="image-20201113154838691"></p>
<h3 id="二分搜索树的添加和查询"><a href="#二分搜索树的添加和查询" class="headerlink" title="二分搜索树的添加和查询"></a>二分搜索树的添加和查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向二分搜索树中添加新的元素e</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       root = add(root, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//向以node为根的二分搜索数中插入元素E， 递归算法</span></span><br><span class="line">   <span class="comment">//返回插入新节点后的二分搜索数的根</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">           size ++;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           node.left = add(node.left, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           node.right = add(node.right, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//看二分搜索树中是否包含元素e</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> contains(root, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//看以node为根的二分搜索树中是否包含元素e，递归算法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索树的前序遍历"><a href="#二分搜索树的前序遍历" class="headerlink" title="二分搜索树的前序遍历"></a>二分搜索树的前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">      preOrder(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//前序遍历以Node为根的二分搜索树，递归算法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(node.e);</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索树的非递归前序遍历"><a href="#二分搜索树的非递归前序遍历" class="headerlink" title="二分搜索树的非递归前序遍历"></a>二分搜索树的非递归前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索树的中序遍历"><a href="#二分搜索树的中序遍历" class="headerlink" title="二分搜索树的中序遍历"></a>二分搜索树的中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分搜索树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历以node为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索树的后续遍历"><a href="#二分搜索树的后续遍历" class="headerlink" title="二分搜索树的后续遍历"></a>二分搜索树的后续遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分搜索树的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历以node为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索树的删除"><a href="#二分搜索树的删除" class="headerlink" title="二分搜索树的删除"></a>二分搜索树的删除</h3><h4 id="删除二分搜索树的最大值和最小值"><a href="#删除二分搜索树的最大值和最小值" class="headerlink" title="删除二分搜索树的最大值和最小值"></a>删除二分搜索树的最大值和最小值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;寻找二分搜索树的最小元素</span><br><span class="line">   public E minimum()&#123;</span><br><span class="line">       if (size &#x3D;&#x3D; 0)&#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;BST is empty&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return minimum(root).e;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Node minimum(Node node)&#123;</span><br><span class="line">       if (node.left &#x3D;&#x3D; null)&#123;</span><br><span class="line">           return node;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return minimum(node.left);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;寻找二分搜索树的最大元素</span><br><span class="line">   public E maximum()&#123;</span><br><span class="line">       if (size &#x3D;&#x3D; 0)&#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;BST is empty&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return maximum(root).e;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Node maximum(Node node)&#123;</span><br><span class="line">       if (node.right &#x3D;&#x3D; null)&#123;</span><br><span class="line">           return node;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return maximum(node.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;从二分搜索树中删除最小值所在的节点，返回最小值</span><br><span class="line">   public E removeMin()&#123;</span><br><span class="line">       E ret &#x3D; minimum();</span><br><span class="line">       root &#x3D; removeMin(root);</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;删除掉以node为根的二分搜索树中的最小节点</span><br><span class="line">   &#x2F;&#x2F;返回删除节点后的二分搜索树的根</span><br><span class="line">   private Node removeMin(Node node)&#123;</span><br><span class="line"></span><br><span class="line">       if (node.left &#x3D;&#x3D; null)&#123;</span><br><span class="line">           Node rightNode &#x3D; node.right;</span><br><span class="line">           node.right &#x3D; null;</span><br><span class="line">           size --;</span><br><span class="line">           return rightNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       node.left &#x3D; removeMin(node.left);</span><br><span class="line"></span><br><span class="line">       return node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;从二分搜索树中删除最大值所在的节点，返回最大值</span><br><span class="line">   public E removeMax()&#123;</span><br><span class="line">       E ret &#x3D; maximum();</span><br><span class="line">       root &#x3D; removeMax(root);</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;删除掉以node为根的二分搜索树中的最大节点</span><br><span class="line">   &#x2F;&#x2F;返回删除节点后的二分搜索树的根</span><br><span class="line">   private Node removeMax(Node node)&#123;</span><br><span class="line"></span><br><span class="line">       if (node.right &#x3D;&#x3D; null)&#123;</span><br><span class="line">           Node leftNode &#x3D; node.left;</span><br><span class="line">           node.left &#x3D; null;</span><br><span class="line">           size --;</span><br><span class="line">           return leftNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       node.right &#x3D; removeMax(node.right);</span><br><span class="line"></span><br><span class="line">       return node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除二分搜索树的任意节点"><a href="#删除二分搜索树的任意节点" class="headerlink" title="删除二分搜索树的任意节点"></a>删除二分搜索树的任意节点</h4><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201116172618540.png" alt="image-20201116172618540"></p>
<h3 id="二分搜索树的层序遍历"><a href="#二分搜索树的层序遍历" class="headerlink" title="二分搜索树的层序遍历"></a>二分搜索树的层序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分搜索树的层序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       q.add(root);</span><br><span class="line">       <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">           Node cur = q.remove();</span><br><span class="line">           System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">               q.add(cur.left);</span><br><span class="line">           <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)</span><br><span class="line">               q.add(cur.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>广度优先遍历的意义<ul>
<li>更快的找到问题的解</li>
<li>常用于算法设计中-最短路径</li>
</ul>
</li>
</ul>
<h2 id="判断BST的合法性"><a href="#判断BST的合法性" class="headerlink" title="判断BST的合法性"></a>判断BST的合法性</h2><p>按照之前的思路，每个节点做的事情就是比较自己和左右子孩子，代码应该这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.val &lt;= left.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.val &gt;= root.right.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法出现了错误，BST的每个节点应该要小于右边子树的所有节点。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201228114609810.png" alt="image-20201228114609810"></p>
<p><strong>出现问题的原因在于，对于每一个节点<code>root</code>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，<code>root</code>的整个左子树都要小于<code>root.val</code>，整个右子树都要大于<code>root.val</code></strong>。</p>
<p>问题是，对于某一个节点<code>root</code>，他只能管得了自己的左右子节点，怎么把<code>root</code>的约束传递给左右子树呢？</p>
<p>请看正确的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">    return isValidBST(root, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val *&#x2F;</span><br><span class="line">boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    if (root &#x3D;&#x3D; null) return true;</span><br><span class="line">    &#x2F;&#x2F; 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span><br><span class="line">    if (min !&#x3D; null &amp;&amp; root.val &lt;&#x3D; min.val) return false;</span><br><span class="line">    if (max !&#x3D; null &amp;&amp; root.val &gt;&#x3D; max.val) return false;</span><br><span class="line">    &#x2F;&#x2F; 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span><br><span class="line">    return isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧</strong>。</p>
<h2 id="在BST搜索一个树的模板"><a href="#在BST搜索一个树的模板" class="headerlink" title="在BST搜索一个树的模板"></a>在BST搜索一个树的模板</h2><p>如果是在二叉树中寻找元素，可以这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isInBST(TreeNode root, int target) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return false;</span><br><span class="line">    if (root.val &#x3D;&#x3D; target) return true;</span><br><span class="line">    &#x2F;&#x2F; 当前节点没找到就递归地去左右子树寻找</span><br><span class="line">    return isInBST(root.left, target)</span><br><span class="line">        || isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有普通二叉树。那么应该如何充分利用信息，把 BST 这个「左小右大」的特性用上？</p>
<p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据<code>target</code>和<code>root.val</code>的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isInBST(TreeNode root, int target) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return false;</span><br><span class="line">    if (root.val &#x3D;&#x3D; target)</span><br><span class="line">        return true;</span><br><span class="line">    if (root.val &lt; target) </span><br><span class="line">        return isInBST(root.right, target);</span><br><span class="line">    if (root.val &gt; target)</span><br><span class="line">        return isInBST(root.left, target);</span><br><span class="line">    &#x2F;&#x2F; root 该做的事做完了，顺带把框架也完成了，妙</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，我们对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BST(TreeNode root, int target) &#123;</span><br><span class="line">    if (root.val &#x3D;&#x3D; target)</span><br><span class="line">        &#x2F;&#x2F; 找到目标，做点什么</span><br><span class="line">    if (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    if (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。</p>
]]></content>
  </entry>
  <entry>
    <title>二分查找法</title>
    <url>/2020/11/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><ul>
<li>对于有序数列，才可以使用二分查找法。（排序的作用）</li>
<li><strong>时间复杂度</strong>（O(logn)）<ul>
<li>如果计算排序时间，时间复杂度就变为O（nlogn）</li>
</ul>
</li>
</ul>
<h2 id="二分查找的递归实现"><a href="#二分查找的递归实现" class="headerlink" title="二分查找的递归实现"></a>二分查找的递归实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(E[] data, E target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> search(data, <span class="number">0</span>, data.length - <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(E[] data, <span class="keyword">int</span> l, <span class="keyword">int</span> r, E target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[mid].compareTo(target) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[mid].compareTo(target) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> search(data, mid + <span class="number">1</span>, r, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> search(data, l, mid -<span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找的非递归实现"><a href="#二分查找的非递归实现" class="headerlink" title="二分查找的非递归实现"></a>二分查找的非递归实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找的非递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">searchR</span><span class="params">(E[] data, E target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = data.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在data[l, r]的范围中查找target</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) /<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data[mid].compareTo(target) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (data[mid].compareTo(target) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改循环不变量，实现二分查找法"><a href="#修改循环不变量，实现二分查找法" class="headerlink" title="修改循环不变量，实现二分查找法"></a>修改循环不变量，实现二分查找法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改循环不变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">searchX</span><span class="params">(E[] data, E target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = data.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在data[l, r)的范围中查找target</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) /<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data[mid].compareTo(target) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (data[mid].compareTo(target) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid; <span class="comment">//继续在data[l, mid]范围内寻找解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找法的变种"><a href="#二分查找法的变种" class="headerlink" title="二分查找法的变种"></a>二分查找法的变种</h1><h2 id="1-Upper"><a href="#1-Upper" class="headerlink" title="1. Upper"></a>1. Upper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &gt; target的最小的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">upper</span><span class="params">(E[] data, E target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = data.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在data[l, r]中寻找解</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) /<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data[mid].compareTo(target) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Ceil"><a href="#2-Ceil" class="headerlink" title="2. Ceil"></a>2. Ceil</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201112165700063.png" alt="image-20201112165700063"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ceil</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">ceil</span><span class="params">(E[] data, E target)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> u = upper(data, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data[u - <span class="number">1</span>].compareTo(target) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> u - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Lower"><a href="#3-Lower" class="headerlink" title="3. Lower"></a>3. Lower</h2><p>查找小于target的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&lt; target 的最大值索引</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">lower</span><span class="params">(E[] data, E target)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> l = -<span class="number">1</span>, r = data.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//在data[l, r]中寻找解</span></span><br><span class="line">       <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">           <span class="keyword">int</span> mid = l + (r - l) /<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (data[mid].compareTo(target) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">               l = mid;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               r = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> l;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题： 可能会产生死循环</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201112171309238.png" alt="image-20201112171309238"></p>
<ul>
<li>解决： int mid = l + (r - l + 1) /2;</li>
</ul>
<h1 id="二分查找法的模板"><a href="#二分查找法的模板" class="headerlink" title="二分查找法的模板"></a>二分查找法的模板</h1><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201112200843726.png" alt="image-20201112200843726"></p>
]]></content>
  </entry>
  <entry>
    <title>Tensorflow搭建神经网络</title>
    <url>/2020/11/17/Tensorflow%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="Tensorflow搭建神经网络"><a href="#Tensorflow搭建神经网络" class="headerlink" title="Tensorflow搭建神经网络"></a>Tensorflow搭建神经网络</h1><p><strong>神经网络</strong>：输入层-&gt;隐藏层-&gt;输出层</p>
<p><strong>神经元的训练：</strong>激活函数</p>
<h2 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201117105318477.png" alt="image-20201117105318477"></p>
<h3 id="1-搭建神经网络基本流程"><a href="#1-搭建神经网络基本流程" class="headerlink" title="1. 搭建神经网络基本流程"></a>1. 搭建神经网络基本流程</h3><p>定义添加神经层的函数</p>
<p>1.训练的数据<br> 2.定义节点准备接收数据<br> 3.定义神经层：隐藏层和预测层<br> 4.定义 loss 表达式<br> 5.选择 optimizer 使 loss 达到最小</p>
<h3 id="3-TensorFlow-基本概念及代码："><a href="#3-TensorFlow-基本概念及代码：" class="headerlink" title="3. TensorFlow 基本概念及代码："></a>3. TensorFlow 基本概念及代码：</h3><ul>
<li><strong>Session</strong></li>
</ul>
<p>矩阵乘法：tf.matmul</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">product = tf.matmul(matrix1, matrix2) <span class="comment"># matrix multiply np.dot(m1, m2)</span></span><br></pre></td></tr></table></figure>

<p>定义 Session，它是个对象，注意大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess &#x3D; tf.Session()</span><br></pre></td></tr></table></figure>

<p>result 要去 sess.run 那里取结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; sess.run(product)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Variable</strong></li>
</ul>
<p>用 tf.Variable 定义变量，与python不同的是，必须先定义它是一个变量，它才是一个变量，初始值为0，还可以给它一个名字 counter：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">state = tf.Variable(0, name=<span class="string">'counter'</span>)</span><br></pre></td></tr></table></figure>

<p>将 new_value 加载到 state 上，counter就被更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update &#x3D; tf.assign(state, new_value)</span><br></pre></td></tr></table></figure>

<p>如果有变量就一定要做初始化：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">init = tf.initialize_all_variables() <span class="meta"># must have <span class="meta-keyword">if</span> <span class="meta-keyword">define</span> variable</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>placeholder：</strong></li>
</ul>
<p>要给节点输入数据时用 placeholder，在 TensorFlow 中用placeholder 来描述等待输入的节点，只需要指定类型即可，然后在执行节点的时候用一个字典来“喂”这些节点。相当于先把变量 hold 住，然后每次从外部传入data，注意 placeholder 和 feed_dict 是绑定用的。</p>
<p>这里简单提一下 feed 机制， 给 feed 提供数据，作为 run()<br> 调用的参数， feed 只在调用它的方法内有效, 方法结束, feed 就会消失。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">input1 = tf.placeholder(tf.float32)</span><br><span class="line">input2 = tf.placeholder(tf.float32)</span><br><span class="line">ouput = tf.mul(input1, input2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"> <span class="built_in">print</span>(sess.run(ouput, feed_dict=&#123;input1: [<span class="number">7.</span>], input2: [<span class="number">2.</span>]&#125;))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>堆，优先队列和堆排序</title>
    <url>/2020/11/24/%E5%A0%86%EF%BC%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="堆，优先队列和堆排序"><a href="#堆，优先队列和堆排序" class="headerlink" title="堆，优先队列和堆排序"></a>堆，优先队列和堆排序</h1><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201120171938554.png" alt="image-20201120171938554"></p>
<ul>
<li>二叉堆是一颗完全二叉树</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201120172031312.png" alt="image-20201120172031312"></p>
<ul>
<li>完全二叉树：把元素顺序排列成树的形状</li>
</ul>
<blockquote>
<p>二叉堆的性质：</p>
<ol>
<li>堆中某个节点的值总是不大于其父亲节点的值（最大堆）</li>
<li>堆中某个节点的值总是不小于于其父亲节点的值（最小堆）</li>
</ol>
</blockquote>
<ul>
<li>用数组存储二叉堆</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201123154702549.png" alt="image-20201123154702549"></p>
<ul>
<li><ul>
<li>从0开始存储</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201123154924385.png" alt="image-20201123154924385"></p>
<ul>
<li>向堆中添加元素和取出最大元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向堆中添加元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">       data.addLast(e);</span><br><span class="line">       siftUp(data.getSize() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           data.swap(k, parent(k));</span><br><span class="line">           k = parent(k);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//寻找最大的元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">findMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (data.getSize() == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not findMax when heap is empty"</span>);</span><br><span class="line">       <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//取出堆中的最大值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       E ret = findMax();</span><br><span class="line"></span><br><span class="line">       data.swap(<span class="number">0</span>, data.getSize() - <span class="number">1</span>);</span><br><span class="line">       data.removeLast();</span><br><span class="line">       siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (leftChild(k) &lt; data.getSize())&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> j = leftChild(k);</span><br><span class="line">           <span class="keyword">if</span> (j + <span class="number">1</span> &lt; data.getSize() &amp;&amp; data.get(j + <span class="number">1</span>).compareTo(data.get(j)) &gt; <span class="number">0</span>)</span><br><span class="line">               j = rightChild(k);</span><br><span class="line">           <span class="comment">//data[j]是leftChild和rightChild中的最大值</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (data.get(k).compareTo(data.get(j)) &gt;= <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           data.swap(k, j);</span><br><span class="line">           k = j;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MaxHeap&lt;E&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (E e: data)&#123;</span><br><span class="line">        maxHeap.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        data[i] = maxHeap.extractMax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化堆排序"><a href="#优化堆排序" class="headerlink" title="优化堆排序"></a>优化堆排序</h3><p>replace和Heapify</p>
<ul>
<li>replace</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201123211724443.png" alt="image-20201123211724443"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出堆中的最大元素，并且替换成元素e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    E ret = findMax();</span><br><span class="line">    data.set(<span class="number">0</span>, e);</span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>heapify</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201123213019744.png" alt="image-20201123213019744"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201123213807913.png" alt="image-20201123213807913"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = parent(arr.length - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            siftDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>堆排序的优化实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化后的堆排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(E[] data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = (data.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">           siftDown(data, i, data.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">           swap(data, <span class="number">0</span>, i);</span><br><span class="line">           siftDown(data, <span class="number">0</span>, i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//对data[0, n) 所形成的最大堆中，索引k的元素， 执行siftDown</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(E[] data, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; data[j + <span class="number">1</span>].compareTo(data[j]) &gt; <span class="number">0</span>)</span><br><span class="line">               j ++;</span><br><span class="line">           <span class="comment">//data[j]是leftChild和rightChild中的最大值</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (data[k].compareTo(data[j]) &gt;= <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           swap(data, k, j);</span><br><span class="line">           k = j;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(E[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       E t = arr[i];</span><br><span class="line">       arr[i] = arr[j];</span><br><span class="line">       arr[j] = t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小堆的实现"><a href="#最小堆的实现" class="headerlink" title="最小堆的实现"></a>最小堆的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(arr);</span><br><span class="line">        <span class="keyword">if</span> (arr.length != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = parent(arr.length - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">                siftDown(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index-0 doesn't have parent."</span>);</span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向堆中添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        data.addLast(e);</span><br><span class="line">        siftUp(data.getSize() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// !!!</span></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            data.swap(k, parent(k));</span><br><span class="line">            k = parent(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!</span></span><br><span class="line">    <span class="comment">// 看堆中的最小元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">findMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.getSize() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not findMax when heap is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出堆中最小元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        E ret = findMin();</span><br><span class="line"></span><br><span class="line">        data.swap(<span class="number">0</span>, data.getSize() - <span class="number">1</span>);</span><br><span class="line">        data.removeLast();</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(leftChild(k) &lt; data.getSize())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = leftChild(k); <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="comment">// !!!</span></span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt; data.getSize() &amp;&amp;</span><br><span class="line">                    data.get(j + <span class="number">1</span>).compareTo(data.get(j)) &lt; <span class="number">0</span> )</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 leftChild 和 rightChild 中的最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// !!!</span></span><br><span class="line">            <span class="keyword">if</span>(data.get(k).compareTo(data.get(j)) &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            data.swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出堆中的最小元素，并且替换成元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        E ret = findMin();</span><br><span class="line">        data.set(<span class="number">0</span>, e);</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">        MinHeap&lt;Integer&gt; minHeap = <span class="keyword">new</span> MinHeap&lt;&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            minHeap.add(random.nextInt(Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            arr[i] = minHeap.extractMin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i-<span class="number">1</span>] &gt; arr[i])</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Error"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Test MinHeap completed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        maxHeap.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.findMax();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>快排和优先队列的比较</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201124202207746.png" alt="image-20201124202207746"></p>
]]></content>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2020/12/05/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201205191359449.png" alt="image-20201205191359449"></p>
<p>空间换时间</p>
<h2 id="哈希函数的设计"><a href="#哈希函数的设计" class="headerlink" title="哈希函数的设计"></a>哈希函数的设计</h2><p>越均匀越好</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201205201304248.png" alt="image-20201205201304248"></p>
<h2 id="哈希冲突的解决-链地址法"><a href="#哈希冲突的解决-链地址法" class="headerlink" title="哈希冲突的解决-链地址法"></a>哈希冲突的解决-链地址法</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201207111909625.png" alt="image-20201207111909625"></p>
<p>绝对值的取法</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201207112103981.png" alt="image-20201207112103981"></p>
<p>查找表的实现方式：链表，红黑树</p>
<p>HashMap就是一个TreeMap数组</p>
<p>HashSet就是一个TreeSet数组</p>
<p>Java8之前，每个位置对应一个链表</p>
<p>Java开始，当哈希冲突达到一定程度，每个位置从链表转成红黑树。转成红黑树的时候，K键值是能比较的。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201207144150988.png" alt="image-20201207144150988"></p>
<p>平均来看的。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201207145921661.png" alt="image-20201207145921661"></p>
<p>哈希表均摊复杂度是O（1），牺牲了顺序性。</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201207150426872.png" alt="image-20201207150426872"></p>
<h2 id="更多的哈希冲突的解决方式"><a href="#更多的哈希冲突的解决方式" class="headerlink" title="更多的哈希冲突的解决方式"></a>更多的哈希冲突的解决方式</h2><ol>
<li>开放地址法</li>
</ol>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201207150817772.png" alt="image-20201207150817772"></p>
<ul>
<li>线性探测</li>
</ul>
<p>31冲突的时候找第一个可以使用的地址。</p>
<ul>
<li>平方探测</li>
</ul>
<p>+1+4+9</p>
<ul>
<li><p>二次哈希</p>
<p>+hash2(key)</p>
</li>
</ul>
<ol start="2">
<li>再哈希法</li>
<li>Coalesced Hashing<ul>
<li>综合了链地址法和开放地址法</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/11/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>复杂度的期望值：O(nlogn)</p>
<blockquote>
<p>普通算法：看最差</p>
<p>随机算法：看期望</p>
</blockquote>
<hr>
<p>核心：把数字放到正确的位置</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201109213520352.png" alt="image-20201109213520352"></p>
<p>递归的含义：</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201109213619057.png" alt="image-20201109213619057"></p>
<p><strong>快速排序中的问题：</strong></p>
<ul>
<li><p>对有序数组使用快速排序，算法的时间复杂度会退化为O（n2），因为会一直循环调用sort函数，只有右边。</p>
<ul>
<li>解决办法：通过随机生成一个位置，与最左边位置的数进行交换。</li>
</ul>
</li>
<li><p>对于一组完全一样的数据，快速排序也会退化为O(n2)</p>
<ul>
<li>解决办法：使用<strong>双路快速排序法</strong></li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201110105317121.png" alt="image-20201110105317121"></p>
<ul>
<li>大致思路：分成两个数组，分别维护，碰到等于的情况会停住，这样就可以是的等于的情况均匀的分布在两个数组当中。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双路快速排序的实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(E[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成[l, r]之间的随机索引</span></span><br><span class="line">    <span class="keyword">int</span> p = l + (<span class="keyword">new</span> Random()).nextInt(r - l + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    swap(arr, l, p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr[l + 1...i - 1] &lt;= v;arr[j+1...r]</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i].compareTo(arr[l]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= i &amp;&amp; arr[j].compareTo(arr[l]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三路快速排序算法：</strong></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201110112706316.png" alt="image-20201110112706316"></p>
<p>最后，递归调用结束的时候：</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201110112819620.png" alt="image-20201110112819620"></p>
<p><strong>三路快排算法的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三路快速排序的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort3ways</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">        sort3ways(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, rnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort3ways</span><span class="params">(E[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, Random rnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成[l, r]之间的随机索引</span></span><br><span class="line">        <span class="keyword">int</span> p = l + rnd.nextInt(r - l + <span class="number">1</span>);</span><br><span class="line">        swap(arr, l, p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//arr[l+1, lt] &lt; v, arr[lt + 1, i - 1] == v; arr[gt, r] &gt; v</span></span><br><span class="line">        <span class="keyword">int</span> lt = l, i =l + <span class="number">1</span>, gt = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; gt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                lt ++;</span><br><span class="line">                swap(arr, i, lt);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                gt --;</span><br><span class="line">                swap(arr, i, gt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, l, lt);</span><br><span class="line">        sort3ways(arr, l, lt - <span class="number">1</span>, rnd);</span><br><span class="line">        sort3ways(arr, gt, r, rnd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="经典引用：LeetCode75"><a href="#经典引用：LeetCode75" class="headerlink" title="经典引用：LeetCode75"></a>经典引用：LeetCode75</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201110161417983.png" alt="image-20201110161417983"></p>
<h4 id="循环不变量定义-1"><a href="#循环不变量定义-1" class="headerlink" title="循环不变量定义 1"></a>循环不变量定义 1</h4><h5 id="循环不变量：声明的变量在遍历的过程中需要保持定义不变。"><a href="#循环不变量：声明的变量在遍历的过程中需要保持定义不变。" class="headerlink" title="循环不变量：声明的变量在遍历的过程中需要保持定义不变。"></a>循环不变量：声明的变量在遍历的过程中需要保持定义不变。</h5><h4 id="设计循环不变量的原则"><a href="#设计循环不变量的原则" class="headerlink" title="设计循环不变量的原则"></a>设计循环不变量的原则</h4><p>说明：设计循环不变量的原则是 不重不漏。</p>
<ul>
<li><p>len 是数组的长度；</p>
</li>
<li><p>变量 zero 是前两个子区间的分界点，一个是闭区间，另一个就必须是开区间；</p>
</li>
<li><p>变量 i 是循环变量，一般设置为开区间，表示 i 之前的元素是遍历过的；</p>
</li>
<li><p>two 是另一个分界线，我设计成闭区间。</p>
</li>
</ul>
<p>  如果循环不变量定义如下：</p>
<ul>
<li><p>所有在子区间 [0, zero) 的元素都等于 0；</p>
</li>
<li><p>所有在子区间 [zero, i) 的元素都等于 1；<br>所有在子区间 [two, len - 1] 的元素都等于 2。</p>
<p>于是编码要解决以下三个问题：</p>
</li>
<li><p>变量初始化应该如何定义；</p>
</li>
<li><p>在遍历的时候，是先加减还是先交换；</p>
</li>
<li><p>什么时候循环终止。<br><strong>处理这三个问题，完全看循环不变量的定义。</strong></p>
</li>
<li><p>编码的时候，zero 和 two 初始化的值就应该保证上面的三个子区间全为空；</p>
</li>
<li><p>在遍历的过程中，「下标先加减再交换」、还是「先交换再加减」就看初始化的时候变量在哪里；</p>
</li>
<li><p>退出循环的条件也看上面定义的循环不变量，在 i == two 成立的时候，上面的三个子区间就正好 不重不漏 地覆盖了整个数组，并且给出的性质成立，题目的任务也就完成了。<br><strong>参考代码 1：</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// all in [0, zero) = 0</span></span><br><span class="line">        <span class="comment">// all in [zero, i) = 1</span></span><br><span class="line">        <span class="comment">// all in [two, len - 1] = 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环终止条件是 i == two，那么循环可以继续的条件是 i &lt; two</span></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候 [0, zero) 为空，设置 zero = 0，</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到 0 的时候，先交换，再加</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候 [two, len - 1] 为空，设置 two = len</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到 2 的时候，先减，再交换</span></span><br><span class="line">        <span class="keyword">int</span> two = len;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当 i == two 上面的三个子区间正好覆盖了全部数组</span></span><br><span class="line">        <span class="comment">// 因此，循环可以继续的条件是 i &lt; two</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, zero);</span><br><span class="line">                zero++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                two--;</span><br><span class="line">                swap(nums, i, two);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用-Select-K"><a href="#应用-Select-K" class="headerlink" title="应用-Select K"></a>应用-Select K</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201110215517070.png" alt="image-20201110215517070"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置</span></span><br><span class="line"><span class="comment">     * 在遍历过程中保持循环不变量的语义</span></span><br><span class="line"><span class="comment">     * 1、[left + 1, j] &lt; nums[left]</span></span><br><span class="line"><span class="comment">     * 2、(j, i] &gt;= nums[left]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 小于 pivot 的元素都被交换到前面</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot</span></span><br><span class="line">        swap(nums, j, left);</span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>线段树、Trie和并查集</title>
    <url>/2020/11/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E3%80%81Trie%E5%92%8C%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="线段树、Trie和并查集"><a href="#线段树、Trie和并查集" class="headerlink" title="线段树、Trie和并查集"></a>线段树、Trie和并查集</h1><h2 id="线段树（区间树）"><a href="#线段树（区间树）" class="headerlink" title="线段树（区间树）"></a>线段树（区间树）</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201129161730698.png" alt="image-20201129161730698"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201129170553129.png" alt="image-20201129170553129"></p>
<ul>
<li>线段树不是完全二叉树</li>
<li>线段树是平衡二叉树（树的深度差距不超过1）</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201129170842568.png" alt="image-20201129170842568"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201129171530405.png" alt="image-20201129171530405"></p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] tree;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> Merger&lt;E&gt; merger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr, Merger&lt;E&gt; merger)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            data[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree = (E[]) <span class="keyword">new</span> Object[<span class="number">4</span> * arr.length];</span><br><span class="line">        buildSegmentTree(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在treeIndex的位置创建表示区间[l...r]的线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            tree[treeIndex] = data[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        buildSegmentTree(leftTreeIndex, l, mid);</span><br><span class="line">        buildSegmentTree(rightTreeIndex, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftTreeIndex] , tree[rightTreeIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= data.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queryL &lt; <span class="number">0</span> || queryL &gt;= data.length || queryR &lt; <span class="number">0</span> || queryR &gt;= data.length || queryL &gt; queryR)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index id illegal"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在以treeID为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> quertL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == quertL &amp;&amp; r == queryR)</span><br><span class="line">            <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (quertL &gt;= mid + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> query(rightTreeIndex, mid + <span class="number">1</span>, r, quertL, queryR);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (queryR &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(leftTreeIndex, l, mid, quertL, queryR);</span><br><span class="line"></span><br><span class="line">        E leftResult = query(leftTreeIndex, l, mid, quertL, queryR);</span><br><span class="line">        E rightResult = query(rightTreeIndex, mid + <span class="number">1</span>, r, quertL, queryR);</span><br><span class="line">        <span class="keyword">return</span> merger.merge(leftResult, rightResult);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将index位置的值，更新为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line"></span><br><span class="line">        data[index] = e;</span><br><span class="line">        set(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, index, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            tree[treeIndex] = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex  = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex  = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= mid + <span class="number">1</span>)</span><br><span class="line">            set(rightTreeIndex, mid + <span class="number">1</span>, r, index, e);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; mid)</span><br><span class="line">            set(leftTreeIndex, l, mid, index, e);</span><br><span class="line"></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] != <span class="keyword">null</span>)</span><br><span class="line">                res.append(tree[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.append(<span class="string">"null"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != tree.length - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">','</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trie-字典树-前缀树"><a href="#Trie-字典树-前缀树" class="headerlink" title="Trie 字典树 前缀树"></a>Trie 字典树 前缀树</h2><h3 id="什么是Trie"><a href="#什么是Trie" class="headerlink" title="什么是Trie"></a>什么是Trie</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201130161328587.png" alt="image-20201130161328587"></p>
<ul>
<li><p>不存储char c也是可以的。因为在根节点的时候我们已经知道了这个单词</p>
</li>
<li><p>还需要存储一个布尔值，来判断当前节点是否已经构成了一个单词</p>
</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201130161703673.png" alt="image-20201130161703673"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> TreeMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向Trie中添加一个新的单词word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">                cur.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur.isWord)&#123;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            size ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单词word是否在Trie中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询是否在Trie中有单词以prefix为前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>回答连接问题</li>
</ul>
<ol>
<li>网络中节点间的连接状态</li>
<li>数学中集合类的实现</li>
</ol>
<ul>
<li>支持的两个动作</li>
</ul>
<ol>
<li>union(p, q)</li>
<li>isConnected(p, q)</li>
</ol>
<h3 id="实现并查集"><a href="#实现并查集" class="headerlink" title="实现并查集"></a>实现并查集</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201201221946776.png" alt="image-20201201221946776"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i ++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看p和q是否属于一个集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pID = find(p);</span><br><span class="line">        <span class="keyword">int</span> qID = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pID == qID)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i ++)</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pID)</span><br><span class="line">                id[i] = qID;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= id.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p is out of bound"</span>);</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现并查集（Quick-Union）"><a href="#实现并查集（Quick-Union）" class="headerlink" title="实现并查集（Quick Union）"></a>实现并查集（Quick Union）</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201202170655620.png" alt="image-20201202170655620"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind2</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind2</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度O(h)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//o(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程，查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">//O(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p is out of bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size优化"><a href="#size优化" class="headerlink" title="size优化"></a>size优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.javafx.tk.quantum.QuantumToolkit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind3</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;  <span class="comment">//sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind3</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//o(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程，查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">//O(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p is out of bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于rank优化"><a href="#基于rank优化" class="headerlink" title="基于rank优化"></a>基于rank优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.javafx.tk.quantum.QuantumToolkit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind4</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;  <span class="comment">//sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind4</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//o(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot) &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程，查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">//O(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p is out of bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201202212207280.png" alt="image-20201202212207280"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201202212309368.png" alt="image-20201202212309368"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.javafx.tk.quantum.QuantumToolkit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind5</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;  <span class="comment">//sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind5</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//o(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot]) &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程，查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">//O(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p is out of bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.javafx.tk.quantum.QuantumToolkit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind5</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;  <span class="comment">//sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind5</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//o(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot]) &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程，查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">//O(h)复杂度，h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"p is out of bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != parent[p])</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(h)</p>
<p>严格意义 O（log*n）</p>
]]></content>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/11/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(nlogn)</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201105165954534.png" alt="image-20201105165954534"></p>
<p><strong>递归函数的基本写法：</strong></p>
<ol>
<li>求解最基本的问题</li>
<li>把原问题转化成更小的问题</li>
</ol>
<p><strong>完全可以把递归函数看成是一个普通的函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MergeSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int mid = (l + r) / 2;可能会数组越界</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        sort(arr, l, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序的区间arr[l, mid] 和 arr[mid+1, r]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(E[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Arrays.copyOfRange复制的时候是复制[l, r+1),所以要写成r+1</span></span><br><span class="line">        E[] temp = Arrays.copyOfRange(arr, l, r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每轮循环为arr[k]赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid)&#123;</span><br><span class="line">                arr[k] = temp[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r)&#123;</span><br><span class="line">                arr[k] = temp[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[i - l].compareTo(temp[j - l]) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                arr[k] = temp[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[i - l].compareTo(temp[j - l]) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                arr[k] = temp[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/03/01/Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 。</p>
<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><ul>
<li>Inversion of Control，控制反转，是一种面向对象的设计思想。</li>
<li>Dependencey Injection，依赖注入，实现了IoC思想。</li>
<li>IoC Container，IoC容器，是实现依赖注入的关键，本质上是一个工厂。</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20201212165839976.png" alt="image-20201212165839976"></p>
<p>通过配置，我们可以管理Bean。</p>
<p>被Spring管理的Bean只被实例化一次，是单例模式的。</p>
<blockquote>
<p>@Scope(singleton)可以产生多个实例。</p>
</blockquote>
<h2 id="注解自动装配"><a href="#注解自动装配" class="headerlink" title="注解自动装配"></a>注解自动装配</h2><ul>
<li><p>注解开发 @Autowired</p>
<p><strong>默认是ByType按类型装配,如果同时有好几个bean引用同一个实体类是，需要@Qualifier（value=“xxx）按照指定id进行注入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier(value = &quot;cat22&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Cat cat;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier(value = &quot;dog&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Dog dog;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解@Resource</p>
<p>默认通过byname的方式实现，如果找不到名字，则通过byType实现。如果两种情况都找不到，就会报错。</p>
</li>
</ul>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><ul>
<li><p>@Nullable 字段标记了这个注解，说明这个字段可以为null；</p>
</li>
<li><p>@Component 组件放在类上，说明这个类被Spring管理了，就是Bean！</p>
<ul>
<li><p>衍生的注解，在web开发中，会按照MVC三层架构分层</p>
<p>dao 【@Repository】</p>
<p>service 【@Service】</p>
<p>controller 【@Controller】</p>
</li>
</ul>
</li>
<li><p>作用域的注解</p>
<ul>
<li>@Scope（”prototype”）  //单例模式</li>
</ul>
</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为啥学习代理模式？这就是SpringAOP的底层</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200807205322551.png" alt="image-20200807205322551"></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>静态代理角色分析</strong></p>
<ul>
<li>抽象角色 : 一般使用接口或者抽象类来实现</li>
<li>真实角色 : 被代理的角色</li>
<li>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</li>
<li>客户  :  使用代理角色来进行一些操作 .</li>
</ul>
<p><strong>静态代理的好处:</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ul>
<p>缺点 :</p>
<ul>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li>
</ul>
<p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<hr>
<p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p>
<p>聊聊AOP：纵向开发，横向开发</p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20200811164619070.png" alt="image-20200811164619070"></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
</li>
<li><ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、</li>
</ul>
</li>
</ul>
<p><strong>JDK的动态代理需要了解两个类</strong></p>
<p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p>
<p>【InvocationHandler：调用处理程序】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLxvyvZMwn9gIEibuxjFwE3enJ4TgKO5PXxM5BPr6Bh7GQwExLvst4AsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object invoke(Object proxy, 方法 method, Object[] args)；</span><br><span class="line">&#x2F;&#x2F;参数</span><br><span class="line">&#x2F;&#x2F;proxy - 调用该方法的代理实例</span><br><span class="line">&#x2F;&#x2F;method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span><br><span class="line">&#x2F;&#x2F;args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span><br></pre></td></tr></table></figure>

<p>【Proxy  : 代理】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLficZiaPU0h9wdeDicTMgBHemVvIdYTsE712DhkDfg0pdRg169oG5FHTmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLCIv9ibKb4c9KjmZNNbsDbZojUy0aB1lS3ibqa1SJaBzkK7KneicEX43Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jML394CqGFmCP1nUlaU9mdLk19o1qIzjicTgDiaPz7ibR371jAo3uNNQ8Qgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;生成代理类</span><br><span class="line">public Object getProxy()&#123;</span><br><span class="line">   return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                                 rent.getClass().getInterfaces(),this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong> </p>
<p>抽象角色和真实角色和之前的一样！</p>
<p>Rent . java 即抽象角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象角色：租房</span><br><span class="line">public interface Rent &#123;</span><br><span class="line">   public void rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host . java 即真实角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真实角色: 房东，房东要出租房子</span><br><span class="line">public class Host implements Rent&#123;</span><br><span class="line">   public void rent() &#123;</span><br><span class="line">       System.out.println(&quot;房屋出租&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyInvocationHandler. java 即代理角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">   private Rent rent;</span><br><span class="line"></span><br><span class="line">   public void setRent(Rent rent) &#123;</span><br><span class="line">       this.rent &#x3D; rent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span><br><span class="line">   public Object getProxy()&#123;</span><br><span class="line">       return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">               rent.getClass().getInterfaces(),this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span><br><span class="line">   &#x2F;&#x2F; 处理代理实例上的方法调用并返回结果</span><br><span class="line">   @Override</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       &#x2F;&#x2F;核心：本质利用反射实现！</span><br><span class="line">       Object result &#x3D; method.invoke(rent, args);</span><br><span class="line">       fare();</span><br><span class="line">       return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;看房</span><br><span class="line">   public void seeHouse()&#123;</span><br><span class="line">       System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;收中介费</span><br><span class="line">   public void fare()&#123;</span><br><span class="line">       System.out.println(&quot;收中介费&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client . java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;租客</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;真实角色</span><br><span class="line">       Host host &#x3D; new Host();</span><br><span class="line">       &#x2F;&#x2F;代理实例的调用处理程序</span><br><span class="line">       ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();</span><br><span class="line">       pih.setRent(host); &#x2F;&#x2F;将真实角色放置进去！</span><br><span class="line">       Rent proxy &#x3D; (Rent)pih.getProxy(); &#x2F;&#x2F;动态生成对应的代理类！</span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、</strong></p>
<blockquote>
<h4 id="深化理解"><a href="#深化理解" class="headerlink" title="深化理解"></a>深化理解</h4></blockquote>
<p>我们来使用动态代理实现代理我们后面写的UserService！</p>
<p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">   private Object target;</span><br><span class="line"></span><br><span class="line">   public void setTarget(Object target) &#123;</span><br><span class="line">       this.target &#x3D; target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;生成代理类</span><br><span class="line">   public Object getProxy()&#123;</span><br><span class="line">       return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">               target.getClass().getInterfaces(),this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; proxy : 代理类</span><br><span class="line">   &#x2F;&#x2F; method : 代理类的调用处理程序的方法对象.</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       log(method.getName());</span><br><span class="line">       Object result &#x3D; method.invoke(target, args);</span><br><span class="line">       return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public void log(String methodName)&#123;</span><br><span class="line">       System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;真实对象</span><br><span class="line">       UserServiceImpl userService &#x3D; new UserServiceImpl();</span><br><span class="line">       &#x2F;&#x2F;代理对象的调用处理程序</span><br><span class="line">       ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();</span><br><span class="line">       pih.setTarget(userService); &#x2F;&#x2F;设置要代理的对象</span><br><span class="line">       UserService proxy &#x3D; (UserService)pih.getProxy(); &#x2F;&#x2F;动态生成代理类！</span><br><span class="line">       proxy.delete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试，增删改查，查看结果！</p>
<blockquote>
<h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h5></blockquote>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<hr>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>那我们接下来就来聊聊AOP吧！</p>
<blockquote>
<p>什么是AOP</p>
</blockquote>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP(面向对象)的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<blockquote>
<p>Aop在Spring中的作用</p>
</blockquote>
<p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210104195325404.png" alt="image-20210104195325404"></p>
<p><img src="https://gitee.com/Hardendless/blogImg/raw/master/img/image-20210104213339896.png" alt="image-20210104213339896"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<blockquote>
<p>使用Spring实现Aop</p>
</blockquote>
<p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第一种方式</strong></p>
<p><strong>通过 Spring API 实现</strong></p>
<p>首先编写我们的业务接口和实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">   public void add();</span><br><span class="line"></span><br><span class="line">   public void delete();</span><br><span class="line"></span><br><span class="line">   public void update();</span><br><span class="line"></span><br><span class="line">   public void search();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void add() &#123;</span><br><span class="line">       System.out.println(&quot;增加用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void delete() &#123;</span><br><span class="line">       System.out.println(&quot;删除用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void update() &#123;</span><br><span class="line">       System.out.println(&quot;更新用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void search() &#123;</span><br><span class="line">       System.out.println(&quot;查询用户&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Log implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;method : 要执行的目标对象的方法</span><br><span class="line">   &#x2F;&#x2F;objects : 被调用的方法的参数</span><br><span class="line">   &#x2F;&#x2F;Object : 目标对象</span><br><span class="line">   @Override</span><br><span class="line">   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AfterLog implements AfterReturningAdvice &#123;</span><br><span class="line">   &#x2F;&#x2F;returnValue 返回值</span><br><span class="line">   &#x2F;&#x2F;method被调用的方法</span><br><span class="line">   &#x2F;&#x2F;args 被调用的方法的对象的参数</span><br><span class="line">   &#x2F;&#x2F;target 被调用的目标对象</span><br><span class="line">   @Override</span><br><span class="line">   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;执行了&quot; + target.getClass().getName()</span><br><span class="line">       +&quot;的&quot;+method.getName()+&quot;方法,&quot;</span><br><span class="line">       +&quot;返回值：&quot;+returnValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--注册bean--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.kuang.service.UserServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.kuang.log.Log&quot;&#x2F;&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;afterLog&quot; class&#x3D;&quot;com.kuang.log.AfterLog&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--aop的配置--&gt;</span><br><span class="line">   &lt;aop:config&gt;</span><br><span class="line">       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span><br><span class="line">       &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br><span class="line">       &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt;</span><br><span class="line">       &lt;aop:advisor advice-ref&#x3D;&quot;afterLog&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void test()&#123;</span><br><span class="line">       ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       UserService userService &#x3D; (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">       userService.search();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p>
<p><strong>第二种方式</strong></p>
<p><strong>自定义类来实现Aop</strong></p>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">   public void before()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   public void after()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去spring中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;diy&quot; class&#x3D;&quot;com.kuang.config.DiyPointcut&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br><span class="line">   &lt;aop:aspect ref&#x3D;&quot;diy&quot;&gt;</span><br><span class="line">       &lt;aop:pointcut id&#x3D;&quot;diyPonitcut&quot; expression&#x3D;&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">       &lt;aop:before pointcut-ref&#x3D;&quot;diyPonitcut&quot; method&#x3D;&quot;before&quot;&#x2F;&gt;</span><br><span class="line">       &lt;aop:after pointcut-ref&#x3D;&quot;diyPonitcut&quot; method&#x3D;&quot;after&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   public void test()&#123;</span><br><span class="line">       ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">       UserService userService &#x3D; (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第三种方式</strong></p>
<p><strong>使用注解实现</strong></p>
<p>第一步：编写一个注解实现的增强类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">   @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void before()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void after()&#123;</span><br><span class="line">       System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">   public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;环绕前&quot;);</span><br><span class="line">       System.out.println(&quot;签名:&quot;+jp.getSignature());</span><br><span class="line">       &#x2F;&#x2F;执行目标方法proceed</span><br><span class="line">       Object proceed &#x3D; jp.proceed();</span><br><span class="line">       System.out.println(&quot;环绕后&quot;);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;annotationPointcut&quot; class&#x3D;&quot;com.kuang.config.AnnotationPointcut&quot;&#x2F;&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>aop:aspectj-autoproxy：说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy &#x2F;&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy &#x2F;&gt;隐藏起来了</span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy &#x2F;&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
</search>
